<HTML>
<HEAD>
<TITLE>xindy: Command List</TITLE>
</HEAD>
<BODY>
<A HREF="manual-2.html"><IMG SRC="prev.gif" ALT="Previous"></A>
<A HREF="manual-4.html"><IMG SRC="next.gif" ALT="Next"></A>
<A HREF="manual.html#toc3"><IMG SRC="toc.gif" ALT="Contents"></A>
<HR>
<H2><A NAME="s3">3. Command List</A></H2>

<P>Here is the complete list of <SF>xindy</SF>'s commands that may be used in
the index style. The symbol <CODE>name</CODE> always refers to a string. We
separate the commands into the <EM>processing</EM> and
<EM>markup</EM> commands. The commands are listed in alphabetical order.</P>
<P>The parenthesis `<CODE>[</CODE>' and `<CODE>]</CODE>' denote optional parts of the
syntax and `<CODE>{</CODE>' and `<CODE>}</CODE>' denote the grouping of elements. A
vertical bar indicates alternatives. However, the enclosing round
braces <EM>are</EM> part of the syntax and must be supplied.</P>


<H2><A NAME="ss3.1">3.1 Processing Commands</A></H2>

<P>Here follows the list of processing commands.</P>
<P>
<A NAME="define-alphabet"></A> 

<HR>
<PRE>
(define-alphabet name string-list)
</PRE>
<HR>
</P>
<P>Defines <CODE>name</CODE> to be the alphabet consisting of all elements of the
<CODE>string-list</CODE>. Examples:</P>
<P>
<PRE>
  (define-alphabet &quot;example-alphabet&quot; (&quot;An&quot; &quot;Example&quot; &quot;Alphabet&quot;))
</PRE>
</P>
<P>defines an alphabet consisting of exactly three symbols. For the
successor relationship holds: <CODE>succ("An")="Example"</CODE> and
<CODE>succ("Example")="Alphabet"</CODE>. The built-in alphabet <CODE>digits</CODE> is
defined as follows:</P>
<P>
<PRE>
  (define-alphabet &quot;digits&quot;
                   (&quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot;))
</PRE>
</P>


<P>
<A NAME="define-attributes"></A> 

<HR>
<PRE>
(define-attributes attribute-list)
</PRE>
<HR>
</P>
<P>Defines all attributes the raw index may contain. Parameter
<CODE>attribute-list</CODE> is a list of list of strings. The nesting level
must not be more than 2. So <CODE>(..(..)..)</CODE> is allowed, whereas
<CODE>(..(..(..)..)..)</CODE> is not.</P>
<P>The list has two kinds of elements: strings and list of strings. A
single string is treated as if it were a single element list. So the
lists <CODE>("definition")</CODE> and <CODE>( ("definition") )</CODE> are equivalent.
All elements forming a list are a so-called <EM>attribute group</EM>. The
members of a group are written to the output file before any member
of the following groups are written.</P>
<P>Examples of valid attributes lists are:</P>
<P><CODE>("definition" "usage")</CODE> defines two attribute groups. The first
one contains all references with the attribute <CODE>definition</CODE> and the
second one all with the attribute <CODE>usage</CODE>.</P>
<P><CODE>(("definition" "important") "usage")</CODE> defines two attribute
groups. The first one contains all references with the attributes
<CODE>definition</CODE> or <CODE>important</CODE> and the second one all with the
attribute <CODE>usage</CODE>. In the attribute group <CODE>("definition"
"important")</CODE> the attribute <CODE>definition</CODE> overrides <CODE>important</CODE>.</P>


<P>
<A NAME="define-crossref-class"></A> 

<HR>
<PRE>
(define-crossref-class name [:unverified])
</PRE>
<HR>
</P>
<P>Defines <CODE>name</CODE> to be a class of cross references. We distinguish
two types of cross reference classes. <EM>Verified</EM> cross reference
classes can be checked for dangling references. If for instance a
cross reference points to the non-existent keyword `foo' a warning is
issued and the user is advised to correct the invalid cross reference.
This is the default. If for some reasons this mechanism must be
deactivated the switch <CODE>:unverified</CODE> can be used to suppress this
behaviour.</P>

<P>
<A NAME="define-letter-group"></A> 

<A NAME="define-letter-groups"></A> 

<HR>
<PRE>
(define-letter-group name [:before lgname] [:after lgname]
                          [:prefixes list-of-prefixes])

(define-letter-groups list-of-letter-groups)
</PRE>
<HR>
</P>
<P>This command defines a letter group with name <CODE>name</CODE>, which must be
a string value, grouping all index entries that have a <EM>sort key</EM>
beginning with the prefix <CODE>name</CODE>. The command</P>
<P>
<PRE>
  (define-letter-group &quot;a&quot;)
</PRE>
</P>
<P>is equivalent to the command</P>
<P>
<PRE>
  (define-letter-group &quot;a&quot; :prefixes (&quot;a&quot;))
</PRE>
</P>
<P>Using the latter form one can associate more than one prefix with a
given letter group. Also further prefixes can be added to an already
existing letter group by simply defining the same letter group again.
This results not in a redefinition but in adding more prefixes to the
currently defined prefixes.</P>
<P>Example:</P>
<P>
<PRE>
  (define-letter-group &quot;a&quot;)
</PRE>
</P>
<P>defines a letter group containing all index entries beginning with the
string <CODE>"a"</CODE>.</P>
<P>
<PRE>
  (define-letter-group &quot;c&quot; :after &quot;a&quot;)
</PRE>
</P>
<P>defines a letter group containing all index entries beginning with the
string <CODE>"c"</CODE>. The letter group appears behind the letter group "a"</P>
<P>
<PRE>
  (define-letter-group &quot;b&quot; :after &quot;a&quot; :before &quot;c&quot;)
</PRE>
</P>
<P>inserts letter group "b" between letter group "a" and "c". This allows
incremental definition of letter groups by extending already defined
ones.</P>
<P>The arguments <CODE>:after</CODE> and <CODE>:before</CODE> define a partial order on
the letter groups. <SF>xindy</SF> tries to convert this partial order into
a total one. If this is impossible due to circular definitions, an
error is reported. If more than one possible total ordering can
result, it is left open which one is used, so one should always define
a complete total order.</P>
<P>The command <CODE>define-letter-groups</CODE> (with an `s' at the end) is
simply an abbreviation for a sequence of
<CODE>define-letter-group</CODE> definitions where the elements are ordered in
the ordering given by the list. Example:</P>
<P>
<PRE>
  (define-letter-groups (&quot;a&quot; &quot;b&quot; &quot;c&quot;)
</PRE>
</P>
<P>equals the definitions</P>
<P>
<PRE>
  (define-letter-group &quot;a&quot;)
  (define-letter-group &quot;b&quot; :after &quot;a&quot;)
  (define-letter-group &quot;c&quot; :after &quot;b&quot;)
</PRE>
</P>
<P>See also commands <CODE>markup-letter-group-list</CODE> and
<CODE>markup-letter-group</CODE> for further information.</P>


<P>
<A NAME="define-location-class"></A> 

<HR>
<PRE>
(define-location-class name layer-list
                       [:min-range-length num]
                       [:hierdepth depth]
                       [:var])
</PRE>
<HR>
</P>
<P>Defines <CODE>name</CODE> to be a location class consisting of the given list
of layers. A list of layers consists of names of basetypes and/or
strings representing separators. Separators must follow the
keyword argument <CODE>:sep</CODE>. If the keyword <CODE>:min-range-length</CODE> is
specified we define the <EM>minimum range length</EM> to be used when
building ranges. The argument <CODE>num</CODE> must be a positive integer
number or the keyword <CODE>none</CODE> in which case the building of ranges
is disallowed. If the switch <CODE>:var</CODE> is specified the declared class
is of type <EM>variable</EM>, i.e. it is a <EM>var-location-class</EM>. Since
building of ranges is currently only allowed for standard classes
<CODE>:var</CODE> and <CODE>:min-range-length</CODE> must not be used together. The
keyword argument <CODE>:hierdepth</CODE> can be used to declare that the
location references have to be tagged in a hierarchical form. Its
argument <CODE>depth</CODE> must be an integer number indicating the number of
layers the hierarchy does contain. See command
<CODE>markup-locref-list</CODE> for more information. Examples:</P>
<P>
<PRE>
  (define-location-class &quot;page-numbers&quot; (&quot;arabic-numbers&quot;)
                         :minimum-range-length 3)
</PRE>
</P>
<P>Defines the location class <CODE>page-numbers</CODE> consisting of one layer
which is the alphabet <CODE>arabic-numbers</CODE>. Since the minimum
range length is set to 3 the location references 2, 3 and 4 don't form
a range because the range length is only 2. But the references 6, 7,
8, and 9 are enough to form a range. Some example instances of this
class are <CODE>0</CODE>, <CODE>1</CODE>, ... <CODE>2313</CODE>, etc.</P>
<P>
<PRE>
  (define-location-class &quot;sections&quot; :var
     (&quot;arabic-numbers&quot; :sep &quot;.&quot;
      &quot;arabic-numbers&quot; :sep &quot;.&quot;
      &quot;arabic-numbers&quot;))
</PRE>
</P>
<P>defines a variable location class. Valid instances are <CODE>1</CODE>,
<CODE>1.1</CODE>, <CODE>1.2</CODE>, <CODE>2</CODE>, <CODE>2.4.5</CODE>, but none of <CODE>2-3</CODE> (wrong
separator), <CODE>1.2.3.4</CODE> (more than 3 layers), <CODE>2.3.iv</CODE> (roman
number instead of arabic one).</P>


<P>
<A NAME="define-location-class-order"></A> 

<HR>
<PRE>
(define-location-class-order list)
</PRE>
<HR>
</P>
<P>Defines the order in which the location classes are written to the
output file. The parameter <CODE>list</CODE> is a list of names of
location classes. Examples:</P>
<P>
<PRE>
  (define-location-class-order
      (&quot;page-numbers&quot; &quot;sections&quot; &quot;xrefs&quot;))
</PRE>
</P>
<P>tells the system that the page numbers should appear before the
section numbers and that the cross references should appear at the
end. If this command is omitted, the declaration order of the
location classes in the index style is implicitly used as the output
order. In the case that a location class does not appear in the list,
the output may behave unexpectedly, so one should always enumerate all
used location classes when using this command.</P>


<P>
<A NAME="define-rule-set"></A> 

<HR>
<PRE>
(define-rule-set name
        [ :inherit-from (&quot;rule-set&quot; &quot;rule-set-2&quot;) ]
        :rules (&lt;rule&gt;...) )
</PRE>
<HR>
</P>
<P>A complete specification of a multi-phase sorting process for a
language requires that some rules have to appear in several subsequent
sorting phases. Rule sets can be used to define a set of rules that
can be instantiated in an arbitrary sorting phase. Basically, they
offer means to separate the definition of sorting rules from their
instantiation, hence, acting as a wrapper for calls to <CODE>sort-rule</CODE>.
They do not add new functionality that is not already present with
<CODE>sort-rule</CODE>.</P>
<P>A rule can be of the form:</P>
<P>
<PRE>
  &lt;rule&gt; ::= (&quot;pattern&quot; &quot;replacement&quot;
              [:string|:bregexp|:egegexp] [:again])
</PRE>
</P>
<P>The following incomplete example defines a new rule set of name
<CODE>isolatin1-tolower</CODE> that inherits definitions from rule set
<CODE>latin-tolower</CODE>, overriding or adding the sort rules in the list of
<CODE>:rules</CODE>.</P>
<P>
<PRE>
   (define-rule-set &quot;isolatin1-tolower&quot;

     :inherit-from (&quot;latin-tolower&quot;)

     :rules ((&quot;À&quot; &quot;à&quot; :string :again)
             (&quot;Á&quot; &quot;á&quot; :string :again)
             (&quot;Â&quot; &quot;â&quot; :string :again)
             (&quot;Ã&quot; &quot;ã&quot; :string :again)
             (&quot;Ä&quot; &quot;ä&quot; :string :again)
             (&quot;Å&quot; &quot;å&quot; :string :again)
             (&quot;Æ&quot; &quot;æ&quot; :string :again)
          ...
            )
   ...)
</PRE>
</P>
<P>Rule sets can be instantiated with the command <CODE>use-rule-set</CODE>. For
further descriptions on the sorting model refer to the command
<CODE>sort-rule</CODE>.</P>

<P>
<A NAME="define-sort-rule-orientations"></A> 

<HR>
<PRE>
(define-sort-rule-orientations (orientations...))
</PRE>
<HR>
</P>
<P>Defines the order for the different sorting phases. The currently
implemented <EM>orientations</EM> are <CODE>forward</CODE> and <CODE>backward</CODE>. This
command must precede all <CODE>sort-rule</CODE> commands in an index style. It
defines the orientations and implicitly sets the maximum number of
sorting phases performed.</P>
<P>For further descriptions on the sorting model refer to the command
<CODE>sort-rule</CODE>.</P>


<P>
<A NAME="merge-rule"></A> 

<HR>
<PRE>
(merge-rule pattern replacement [:again]
                                [:bregexp | :eregexp | :string])
</PRE>
<HR>
</P>
<P>Defines a keyword mapping rule that can be used to generate the
<EM>merge key</EM> from the <EM>main key</EM> of an index entry. This mapping
is necessary to map all keywords that are differently written but
belong to the same keyword to the same canonical keyword.</P>
<P>The parameter <CODE>pattern</CODE> can be a POSIX-compliant regular expression
or an ordinary string. The implementation uses the GNU Rx regular
expression library which implements the POSIX regular expressions.
Regular expressions (REs) can be specified as <EM>basic regular
expressions</EM> (BREs) or <EM>extended regular expressions</EM> (EREs). You
can use the switch <CODE>:bregexp</CODE> to force the interpretation of the
pattern as a BRE, or <CODE>:eregexp</CODE> to interpret it as an ERE. If you
want <SF>xindy</SF> to interpret the pattern literally, use the switch
<CODE>:string</CODE>. If none of these switches is selected, <SF>xindy</SF> uses
an auto-detection mechanism to decide, if the pattern is a regular
expression or not. If it recognizes the pattern as a RE, it interprets
it as an ERE by default.</P>
<P>The parameter <CODE>replacement</CODE> must be
a string possibly containing the special characters <CODE>&amp;</CODE>
(substitutes for the complete match) and 
<CODE>
\1
</CODE>
,...,
<CODE>
\9
</CODE>

(substituting for the <EM>n</EM>-th submatch. Examples:</P>
<P>
<PRE>
  (merge-rule &quot;A&quot; &quot;a&quot;)
</PRE>

replaces each occurrence of the uppercase letter `<CODE>A</CODE>' with its
lowercase counterpart.</P>
<P>
<PRE>
  (merge-rule &quot;\~&quot;([AEOUaeou])&quot; &quot;\1&quot;)
</PRE>

transforms the TeX umlaut-letters into their stripped counterparts,
such that `
<CODE>
\"A
</CODE>
' is treated as an `<CODE>A</CODE>' afterwards.</P>
<P>The following sequences have a special meaning:</P>
<P>`
<CODE>
~n
</CODE>
' : End of line symbol (<EM>linefeed</EM>).</P>
<P>`
<CODE>
~b
</CODE>
' : The ISO-Latin character with the lowest ordinal number.</P>
<P>`
<CODE>
~e
</CODE>
' : The ISO-Latin character with the highest ordinal number.</P>
<P>`
<CODE>
~~
</CODE>
' : The tilde character.</P>
<P>`
<CODE>
~"
</CODE>
' : The double quote character.</P>
<P>Tilde characters and double quotes have to be quoted themselves with a
tilde character. The special characters `
<CODE>
~b
</CODE>
' and
`
<CODE>
~e
</CODE>
' allow the definition of arbitrary sorting orders by
rules. In connection with an additional character every position in
the alphabet can be described. E.g. `
<CODE>
m~e
</CODE>
' is
lexicographically placed between `<CODE>m</CODE>' and `<CODE>n</CODE>'.</P>
<P>Due to efficiency, rules that just exchange characters or substitute
constant character sequences are not treated as regular expressions.
Therefore, instead of using the rule</P>
<P>
<PRE>
  (merge-rule &quot;[A-Z]&quot; &quot;&ampx&quot;)
</PRE>
</P>
<P>it is more efficient (though less comfortable) to use</P>
<P>
<PRE>
  (merge-rule &quot;A&quot; &quot;Ax&quot;)
  (merge-rule &quot;B&quot; &quot;Bx&quot;)
  ...
  (merge-rule &quot;Z&quot; &quot;Zx&quot;)
</PRE>
</P>
<P>Usually rules are applied in order of their definition. Rules with a
special prefix precede those that begin with a class of characters, so
that the search pattern `<CODE>alpha</CODE>' is checked before `<CODE>.*</CODE>', but
`<CODE>auto</CODE>' and `<CODE>a.*</CODE>' are checked in order of their definition.</P>
<P>The first rule from a style file that matches the input is
applied and the process restarts behind the substituted text. If no
rule could be applied, the actual character is copied from the input
and the process continues with the next character.</P>
<P>Sometimes it is necessary to apply rules anew to the result of a
transformation. By specifying the keyword argument <CODE>:again</CODE> in the
merge rule the rule is marked as <EM>mutable</EM>, which means that after
using this rule the transformation process shall restart at the same
place. E.g. the rule</P>
<P>
<PRE>
  (merge-rule &quot;\$(.*)\$&quot; &quot;\1&quot; :again)
</PRE>
</P>
<P>deletes <EM>all</EM> surrounding `
<CODE>
$
</CODE>
' symbols from the input.</P>
<P>See also command <CODE>sort-rule</CODE>.</P>

<P>
<A NAME="merge-to"></A> 

<HR>
<PRE>
(merge-to attr-from attr-to [:drop])
</PRE>
<HR>
</P>
<P>A <EM>merge rule</EM> says that the attribute <CODE>attr-from</CODE> can be used
to build ranges in <CODE>attr-to</CODE>. Both attributes must name valid
attribute names. The switch <CODE>:drop</CODE> indicates, that the original
location reference with attribute <CODE>attr-from</CODE> has to be dropped
(removed), if a successful range was built with location references in
attribute <CODE>attr-to</CODE>. A detailed description is given in the section
about processing phases.</P>


<P>
<A NAME="require"></A> 

<HR>
<PRE>
(require filename)
</PRE>
<HR>
</P>
<P>This command allows to load more index style modules. The module is
searched in the directories defined in the search path. The file is
read in and processing of the current file continues. The argument
<CODE>filename</CODE> must be a string. This allows to decompose the
index style into several modules that can be included into the topmost
index style file. Example:</P>
<P>
<PRE>
  (require &quot;french/alphabet.xdy&quot;)
  (require &quot;french/sort-rules.xdy&quot;)
  (require &quot;tex/locations.xdy&quot;)
  (require &quot;tex/markup.xdy&quot;)
</PRE>
</P>
<P>Submodules can load other submodules as well. If a file is required
that was already loaded, the <CODE>require</CODE> command is simply ignored
and processing continues without including this file twice. See also
command <CODE>searchpath</CODE>.</P>


<P>
<A NAME="searchpath"></A> 

<HR>
<PRE>
(searchpath {path-string | path-list})
</PRE>
<HR>
</P>
<P>This command adds the given paths to the list of paths, <SF>xindy</SF>
searches for index style files. The argument <CODE>path-string</CODE> must be
a colon-separated string of directory names. If this path ends with a
colon the default search path is added to the end of the path list.
Example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  (searchpath &quot;.:/usr/local/lib/xindy:/usr/local/lib/xindy/english:&quot;)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>adds the specified directories to the search path. Since the last path
ends with a colon, the built-in search path is added at the end.
Specifying</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  (searchpath (&quot;.&quot;
               &quot;/usr/local/lib/xindy&quot;
               &quot;/usr/local/lib/xindy/english&quot;
               :default))
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>yields exactly the same result as the example above. Here
<CODE>path-list</CODE> must be a list of strings and/or the keyword(s)
<CODE>:default</CODE> and <CODE>:last</CODE>. The keyword <CODE>:default</CODE> signifies that
the default pathnames are to be inserted at the specified position in
the list. The keyword <CODE>:last</CODE> allows to insert the currently active
paths at the indicated position. Since this allows to insert the
built-in paths at any position and incrementally adding new paths to
the search path, this version of the command ist more flexible than
the first version.</P>

<P>
<A NAME="sort-rule"></A> 

<HR>
<PRE>
(sort-rule pattern replacement [:run level] [:again])
</PRE>
<HR>
</P>
<P>Defines a keyword mapping rule that can be used to generate the
<EM>sort key</EM> of an index entry from the <EM>merge key</EM>. This key is
used to sort the index entries lexicographically after they have been
merged using the merge key.</P>
<P>The argument <CODE>:run</CODE> indicates that this rule is only in effect
a the specified <EM>level</EM> (default is level 0). For a detailed
discussion on the definition of sort rules for different layers refer
to the documentation about the new sorting scheme
(<CODE>new-sort-rules</CODE>) that comes with this distribution.</P>
<P>See command <CODE>merge-rule</CODE> for more information about keyword
rules.</P>


<P>
<A NAME="use-rule-set"></A> 

<HR>
<PRE>
(use-rule-set [:run phase]
              [:rule-set ( &lt;rule-set&gt;... ))
</PRE>
<HR>
</P>
<P>This command instantiates the gives rule sets to be in effect at
sorting phase <CODE>phase</CODE>. The order of the rule sets given with
argument <CODE>:rule-set</CODE> is significant. Rule set entries of rule set
appearing at the beginning of the list override entries in rule sets
at the end of the list.</P>
<P>The following example declares that in phase 0 the rule sets
<CODE>din5007</CODE> and <CODE>isolatin1-tolower</CODE> should be active, whereas in
phase 2 the other rule sets have to be applied.</P>
<P>
<PRE>
  (use-rule-set :run 0
                :rule-set (&quot;din5007&quot; &quot;isolatin1-tolower&quot;))

  (use-rule-set :run 1
                :rule-set (&quot;resolve-umlauts&quot;
                           &quot;resolve-sharp-s&quot;
                           &quot;isolatin1-tolower&quot;
                           ))
</PRE>
</P>
<P>For a discussion on rule sets refer to command <CODE>define-rule-set</CODE>.</P>




<H2><A NAME="ss3.2">3.2 Markup Commands</A></H2>


<P>The following commands can be used to define the markup of the index.
They don't have any influence on the indexing process. Since the
markup scheme is characterized by the concept of <EM>environments</EM>,
the syntax and naming scheme of all commands follows a simple
structure.</P>
<P>The commands can be separated into <EM>environment</EM>  and
<EM>list-environment</EM> commands. All commands of the first group
support the keyword arguments <CODE>:open</CODE> and <CODE>:close</CODE>, whereas the
second group additionally supports the keyword argument <CODE>:sep</CODE>. If
one of these keyword arguments is missing, the default markup tag is
<EM>always</EM> the empty tag. The <CODE>:open</CODE> tag is always printed before
the object itself and the <CODE>:close</CODE> tag is always printed after the
object has been printed. If a list is printed the <CODE>:sep</CODE>tag is
printed between two elements of the list but not before the first
element, or after the last one. All commands dealing with a list have
the suffix `<CODE>-list</CODE>' as part of their command name.</P>
<P>Since the number of commands and the heavy usage of <EM>default</EM> and
<EM>specialized</EM> tags makes the markup somehow complex (but very
powerful) we have added a mechanism to trace the markup tags
<SF>xindy</SF> omits during its markup phase with the command
<CODE>markup-trace</CODE>.</P>
<P>Here follows the list of markup commands in alphabetical order with
some of the commands grouped together.</P>

<P>
<A NAME="markup-attribute-group"></A> 

<A NAME="markup-attribute-group-list"></A> 

<HR>
<PRE>
(markup-attribute-group-list [:open string] [:close string]
                             [:sep string])

(markup-attribute-group      [:open string] [:close string]
                             [:group group-num])
</PRE>
<HR>
</P>
<P>Location class groups consist of lists of attribute groups. The markup
of this list can be defined with the command
<CODE>markup-attribute-group-list</CODE>.</P>
<P>To allow different markup for different attribute groups the command
<CODE>markup-attribute-group</CODE> can be specialized on the group number
with the keyword argument <CODE>:group</CODE> which must be an integer number.
E.g., given are the groups <CODE>("definition" "theorem")</CODE> and
<CODE>("default")</CODE> with group numbers 0 and 1, then</P>
<P>
<PRE>
  (markup-attribute-group :open &quot;&lt;group0&gt;&quot; :close &quot;&lt;/group0&gt;&quot;
                          :group 0)

  (markup-attribute-group :open &quot;&lt;group1&gt;&quot; :close &quot;&lt;/group1&gt;&quot;
                          :group 1)
</PRE>
</P>
<P>can be used to assign different markup for both groups in a SGML-based
language.</P>

<P>
<A NAME="markup-crossref-layer"></A> 

<A NAME="markup-crossref-layer-list"></A> 

<A NAME="markup-crossref-list"></A> 

<HR>
<PRE>
(markup-crossref-list       [:open string] [:close string]
                            [:sep string]
                            [:class crossref-class])

(markup-crossref-layer-list [:open string] [:close string]
                            [:sep string]
                            [:class crossref-class])

(markup-crossref-layer      [:open string] [:close string]
                            [:class crossref-class])
</PRE>
<HR>
</P>
<P>A crossref class group contains cross references of the same class.
The separator between the classes is defined with the
<CODE>(markup-locclass-list :sep)</CODE>-parameter. A list of cross references
can be tagged with the command <CODE>markup-crossref-list</CODE> that
specializes on the <CODE>:class</CODE> argument.</P>
<P>Each cross reference is determined by a list of layers indicating
the target of the cross reference. To define a suitable markup for
such a list the command <CODE>markup-crossref-layer-list</CODE> can be used.</P>
<P>Each layer of a cross reference can be assigned two tags that
specialize on the class of the reference, like all other commands.</P>
<P>A suitable markup for a cross reference class <CODE>see</CODE> within LaTeX2e
could look like that:</P>
<P>
<PRE>
  (markup-crossref-list :class &quot;see&quot; :open &quot;\emph{see} &quot;
                                     :sep  &quot;; &quot;)
  (markup-crossref-layer-list :class &quot;see&quot; :sep &quot;,&quot;)
  (markup-crossref-layer :class &quot;see&quot;
                                     :open &quot;\textbf{&quot; :close &quot;}&quot;)
</PRE>
</P>
<P>An example output could look like</P>
<P>
<BLOCKQUOTE>
... <EM>see</EM>  <B>house</B>; <B>garden</B>,<B>winter</B>; <B>greenhouse</B>
</BLOCKQUOTE>
</P>

<P>
<A NAME="markup-index"></A> 

<HR>
<PRE>
(markup-index [:open string] [:close string]
              [ :flat | :tree | :hierdepth depth ])
</PRE>
<HR>
</P>
<P>Defines the markup tags that enclose the whole index via the
<CODE>:open</CODE> and <CODE>:close</CODE> parameters. Examples:</P>
<P>
<PRE>
  (markup-index :open  &quot;Here comes the index~n&quot;
                :close &quot;That's all folks!~n&quot;)
</PRE>
</P>
<P>defines that the <CODE>:open</CODE> string is printed before the rest of the
index and the <CODE>:close</CODE> string appears after the index is printed.</P>
<P>Additionally one can specify the form of the generated index. It is
possible to produce flat indexes by specifying the switch <CODE>:flat</CODE>,
to generate a tree with the <CODE>:tree</CODE> switch or any kind of mixture
between both by specifying the depth up to which trees shall be built
with the parameter <CODE>:hierdepth</CODE>. Its argument <CODE>depth</CODE> is the
number of layers that can be formed into a tree. Therefore <CODE>:flat</CODE>
is an abbrevation of <CODE>:hierdepth 0</CODE> and <CODE>:tree</CODE> is an
abbrevation of <CODE>:hierdepth max-depth</CODE>, with <CODE>max-depth</CODE> being
the maximum number of layers a keyword has. An example: the keywords</P>
<P>
<PRE>
  (&quot;tree&quot; &quot;binary&quot; &quot;AVL&quot;)
  (&quot;tree&quot; &quot;binary&quot; &quot;natural&quot;)
</PRE>
</P>
<P>can be transformed in the following ways:</P>
<P>A flat index (<CODE>:flat</CODE> or <CODE>:hierdepth 0</CODE>)</P>
<P>
<PRE>
  tree binary AVL
  tree binary natural
</PRE>
</P>
<P>with <CODE>:hierdepth 1</CODE></P>
<P>
<PRE>
  tree
     binary  AVL
     binary  natural
</PRE>
</P>
<P>and a tree (<CODE>:tree</CODE> or <CODE>:hierdepth</CODE> &gt; 1)</P>
<P>
<PRE>
  tree
     binary
        AVL
        natural
</PRE>
</P>
<P>Most often one will create tree-like indexes or ones that are flat.</P>

<P>
<A NAME="markup-indexentry-list"></A> 

<A NAME="markup-indexentry"></A> 

<HR>
<PRE>
(markup-indexentry-list [:open string] [:close string]
                        [:sep string]  [:depth integer])

(markup-indexentry      [:open string] [:close string]
                        [:depth integer])
</PRE>
<HR>
</P>
<P>Letter groups consists of a list of index entries. The command
<CODE>markup-indexentry-list</CODE> defines the markup of these lists. The
markup can be specialized on the depth if the index is hierarchically
organized. The command</P>
<P>
<PRE>
  (markup-indexentry-list :open  &quot;\begin{IdxentList}&quot;
                          :close &quot;\end{IdxentList}&quot;
                          :sep   &quot;~n&quot;)
</PRE>
</P>
<P>defines that the index entries of all layers are wrapped into the
given markup tags. If additionally</P>
<P>
<PRE>
  (markup-indexentry-list :open  &quot;\begin{IdxentListII}&quot;
                          :close &quot;\end{IdxentListII}&quot;
                          :sep   &quot;~n&quot;
                          :depth 2)
</PRE>
</P>
<P>is defined, all index entry lists of all layers (except layer 2) are
tagged according to the first specification, and the index entry list
within depth 2 are tagged according to the second rule.</P>
<P>The command <CODE>markup-indexentry</CODE> defines the markup of an index entry
at a given depth. Since index entries may also contain subentries and
the markup for subentries may be different in different layers, the
optional keyword argument <CODE>:depth</CODE> can be used to assign different
markup for different layers. If depth is ommited the default markup
for all possible depths is defined. The top-most index entries have
depth 0.</P>
<P>
<PRE>
  (markup-indexentry :open  &quot;\begin{Indexentry}&quot;
                     :close &quot;\end{Indexentry}&quot;)
</PRE>
</P>
<P>defines that the index entries of all layers are wrapped into the
given markup tags. If additionally</P>
<P>
<PRE>
  (markup-indexentry :open  &quot;\begin{IndexentryII}&quot;
                     :close &quot;\end{IndexentryII}&quot;
                     :depth 2)
</PRE>
</P>
<P>is defined, all index entries of all layers (except layer 2) are tagged
according to the first specification, and the index entries with depth
2 are tagged according to the second rule.</P>

<P>
<A NAME="markup-keyword-list"></A> 

<A NAME="markup-keyword"></A> 

<HR>
<PRE>
(markup-keyword-list [:open string] [:close string]
                     [:sep string] [:depth integer])

(markup-keyword      [:open string] [:close string]
                     [:depth integer])
</PRE>
<HR>
</P>

<P>The print key of an index entry consists of a list of strings. The
markup of this list can be defined with the command
<CODE>markup-keyword-list</CODE>. The keyword argument <CODE>:depth</CODE> may be
specified to define the markup of the list at a particular depth.</P>
<P>The keyword of an index entry consists of a list of strings. Each of
these components is tagged with the strings defined with the command
<CODE>markup-keyword</CODE>. Since we maybe need different markup for
different layers, the optional keyword argument can be used to
specialize this markup for some depth.</P>

<P>
<A NAME="markup-letter-group-list"></A> 

<A NAME="markup-letter-group"></A> 

<HR>
<PRE>
(markup-letter-group-list [:open string] [:close string]
                          [:sep string])

(markup-letter-group  [:open string] [:close string] [:group group-name]
                      [:open-head string] [:close-head string]
                      [:upcase | :downcase | :capitalize])
</PRE>
<HR>
</P>
<P>The first command defines the markup of the letter group with name
<CODE>group-name</CODE>. Since the markup of letter groups often contains the
name of the letter group as a part of it, the other keyword arguments
allow an additional markup for this group name. If one of the
parameters <CODE>:open-head</CODE> and <CODE>:close-head</CODE> is specified
additional markup is added as can be described as follows:</P>
<P>
<PRE>
  &lt;OPEN&gt;
     IF (:open-head OR :close-head)
       &lt;OPEN-HEAD&gt;
         transformer-of(&lt;GROUP-NAME&gt;)
       &lt;CLOSE-HEAD&gt;
     FI
     &lt;INDEXENTRIES...&gt;
  &lt;CLOSE&gt;
</PRE>
</P>
<P>Here, <CODE>transformer-of</CODE> is a function that possibly transforms the
string representing the group name into another string. The
transformers we currently support can be specified with the switches
<CODE>:upcase</CODE>, <CODE>:downcase</CODE> and <CODE>:capitalize</CODE> which result in the
corresponding string conversions. If none of them is specified no
transformation is done at all.</P>
<P>The command <CODE>markup-letter-group</CODE> defines the markup of the list of
letter groups.</P>

<P>
<A NAME="markup-locclass-list"></A> 

<HR>
<PRE>
(markup-locclass-list [:open string] [:close string]
                      [:sep string])
</PRE>
<HR>
</P>
<P>Each index entry contains a list of location class groups. This markup
command can be used to define the markup of this list.</P>

<P>
<A NAME="markup-locref"></A> 

<HR>
<PRE>
(markup-locref [:open string] [:close string]
               [:class locref-class]
               [:attr  attribute]
               [:depth integer])
</PRE>
<HR>
</P>
<P>The markup tags of a location reference can be specialized on the
three arguments <CODE>:class</CODE>, <CODE>:attr</CODE> and additionally, if
sub-references are used, <CODE>:depth</CODE>. Most often one will only use a
tag depending on the attribute. For example, all location references
with the attribute <CODE>definition</CODE> should appear in a font series like
bold, emphasizing the importance of this location reference; those
with the attribute <CODE>default</CODE> in font shape italic. The markup in
this case would not specialize on the depth or any particular class. A
valid definition, suitable for a usage within HTML, could look like
this.</P>
<P>
<PRE>
  (markup-locref :open &quot;&lt;B&gt;&quot; :close &quot;&lt;/B&gt;&quot; :attr &quot;definition&quot;)
  (markup-locref :open &quot;&lt;I&gt;&quot; :close &quot;&lt;/I&gt;&quot; :attr &quot;default&quot;)
</PRE>
</P>

<P>
<A NAME="markup-locref-class"></A> 

<HR>
<PRE>
(markup-locref-class [:open string] [:close string]
                     [:class locref-class])
</PRE>
<HR>
</P>
<P>All location references of a particular location reference class can
be wrapped into the tags defined by this command. It specializes on
the keyword argument <CODE>:class</CODE>.</P>

<P>
<A NAME="markup-locref-layer-list"></A> 

<A NAME="markup-locref-layer"></A> 

<HR>
<PRE>
(markup-locref-layer      [:open string] [:close string]
                          [:depth integer] [:layer integer]
                          [:class locref-class])

(markup-locref-layer-list [:open string] [:close string]
                          [:sep string]
                          [:depth integer]
                          [:class locref-class])
</PRE>
<HR>
</P>
<P>A location reference contains a list of location reference layers. The
second markup command can be used to markup this list. It specializes
on the class of the location references and the depth (if
sub-references are used).</P>
<P>The first command allows to tag the elements of a layer list
differently. The first element of this list can is specialisable with
<CODE>:layer 0</CODE>, the next element with <CODE>:layer 1</CODE>, etc. See the next
example for an example.</P>

<P>
<A NAME="markup-locref-list"></A> 

<HR>
<PRE>
(markup-locref-list [:open string] [:close string] [:sep string]
                    [:depth integer] [:class locref-class])
</PRE>
<HR>
</P>
<P>An attribute group contains a list of location references and/or
ranges. Additionally a layered location reference itself may contain
sub-references that are stored as a list of location references. We
specialize the markup for these lists on the location class they
belong to with the keyword argument <CODE>:class</CODE>, and on <CODE>:depth</CODE>
that specializes on the different subentry levels when using
location references with sub-references.</P>
<P>Given is a list of location references that have the class description</P>
<P>
<PRE>
  (define-location-class &quot;Appendix&quot;
                         (&quot;ALPHA&quot; :sep &quot;-&quot; &quot;arabic-numbers&quot;)
                         :hierdepth 2)
</PRE>
</P>
<P>This location class has instances like <CODE>A-1</CODE>, <CODE>B-5</CODE>, etc. The
keyword argument <CODE>:hierdepth 2</CODE> informs <SF>xindy</SF> to markup these
location references in a hierarchical form. With the commands</P>
<P>
<PRE>
  (markup-locref-list            :sep &quot;; &quot;
                       :depth 0  :class &quot;Appendix&quot;)
  (markup-locref-list  :open &quot; &quot; :sep &quot;,&quot;
                       :depth 1  :class &quot;Appendix&quot;)
  (markup-locref-layer :open &quot;{\bf &quot; :close &quot;}&quot; :layer 0
                       :depth 0  :class &quot;Appendix&quot;)
</PRE>
</P>
<P>we obtain a markup sequence for some example data that could look like</P>
<P>
<PRE>
  {\bf A} 1,2,5; {\bf B} 5,6,9; {\bf D} 1,5,8; ...
</PRE>
</P>


<P>
<A NAME="markup-range"></A> 

<HR>
<PRE>
(markup-range [:open string] [:close string] [:sep string]
              [:class locref-class]
              [:length num] [:ignore-end])
</PRE>
<HR>
</P>
<P>A range consists of two location references. Markup can be specified
with the <CODE>:open</CODE> and <CODE>:close</CODE> arguments and one separator given
by the argument <CODE>:sep</CODE>.</P>
<P>Since both location references are tagged with markup defined by the
command <CODE>markup-locref</CODE> a specialization on attributes or depth is
not necessary. Specialization is allowed on the class they belong to,
because the separator between two location refences may be different
for each location class. Argument <CODE>:length</CODE> can be used to define
different markup for different lengths. In conjunction with
<CODE>:length</CODE> is may be useful not to print the second location
reference at all. For example, one wishes to markup ranges of length 1
in the form <EM>Xf.</EM> instead of <EM>X--Y</EM>. This can be accomplished
with the switch <CODE>:ignore-end</CODE>.</P>
<P>The markup tags for a range <EM>(X,Y)</EM> can be described as follows:</P>
<P>
<PRE>
  &lt;OPEN&gt;
    Markup of location reference X
  &lt;SEP&gt;
    IF (not :ignore-end)
       Markup of location reference Y
    FI
  &lt;CLOSE&gt;
</PRE>
</P>

<P>The following tags can be used to define a range of page numbers
(given in a location class <CODE>page-numbers</CODE>) without considering the
open and close parameters:</P>
<P>
<PRE>
  (markup-range :sep &quot;-&quot; :class &quot;page-numbers&quot;)
</PRE>
</P>
<P>Location ranges then appear separated by a hyphen in a form like this:</P>
<P>
<PRE>
   ..., 5-8, 19-23, ...
</PRE>
</P>

<P>
<A NAME="markup-trace"></A> 

<HR>
<PRE>
(markup-trace [:on] [:open string] [:close string])
</PRE>
<HR>
</P>
<P>This command can be used to activate the tracing of all
markup commands <SF>xindy</SF> executes. The switch <CODE>:on</CODE> activates the
trace. If <CODE>:on</CODE> is omitted, the command line flag <CODE>-t</CODE> can be
used as well. All tags which are emitted but not yet defined
explicitly by the user are tagged with a symbolic notation indicating
the commands that must be used to define this tag. The defaults for
the keyword argument <CODE>:open</CODE> is `<CODE>&lt;</CODE>' and for <CODE>:close</CODE> is
`<CODE>></CODE>'. The beginning of an example output could look like:</P>
<P>
<PRE>
  &lt;INDEX:OPEN&gt;
    &lt;LETTER-GROUP-LIST:OPEN&gt;
      &lt;LETTER-GROUP:OPEN [&quot;a&quot;]&gt;
        &lt;INDEXENTRY-LIST:OPEN [0]&gt;
          &lt;INDEXENTRY:OPEN [0]&gt;
            &lt;KEYWORD-LIST:OPEN [0]&gt;
              &lt;KEYWORD:OPEN [0]&gt;
   ...
</PRE>
</P>
<P>We use a simple indentation scheme to make the structure of the tags
visible. The symbolic tag <CODE>&lt;LETTER-GROUP:OPEN ["a"]></CODE> for example
indicates that the tag that can be specified with the command</P>
<P>
<PRE>
  (markup-letter-group :open &quot;XXX&quot; :group &quot;a&quot; ... )
</PRE>
</P>
<P>is emitted at this point in the markup process. By incrementally
adding markup commands to the index, more and more tags can be defined
until the whole markup is defined. This general mechanism should allow
everyone understand the markup process. The best is to start with a
small index, define the complete markup and afterwards process the
whole index. Additionally one can enclose the symbolic tags into an
environment that is neutral to the document preparation system, such
as a comment. For TeX this could be</P>
<P>
<PRE>
  (markup-trace :open &quot;%%&quot; :close &quot;~n&quot;)
</PRE>
</P>
<P>or a definition in the TeX document like</P>
<P>
<PRE>
  \def\ignore#1{}
</PRE>
</P>
<P>combined with the command</P>
<P>
<PRE>
  (markup-trace :open &quot;\ignore{&quot; :close &quot;}&quot;)
</PRE>
</P>


<P>
<A NAME="raw-index"></A> 
</P>

<H2><A NAME="ss3.3">3.3 Raw Index Interface</A></H2>


<P>This section can be skipped if the reader is not interested in
adapting <SF>xindy</SF> to a new document preparation system.</P>
<P>The raw index is the file that represents the index that is to be
processed. Since many different document preparation systems may use
different forms of index representations, their output must be
transformed in a form readable by <SF>xindy</SF>. We also could have
written an configurable parser performing this task, but usually a
tool written with some text processing tools such as <CODE>perl</CODE>,
<CODE>sed</CODE> or <CODE>awk</CODE> can achieve the same task as well. Therefore,
adapting <SF>xindy</SF> to a completely different system can mostly be
done by writing an appropriate raw index filter.</P>
<P>The format of the raw index interface of <SF>xindy</SF> is defined as
follows:</P>
<P>
<A NAME="indexentry"></A> 

<HR>
<PRE>
(indexentry { :key string-list [:print string-list]
            | :tkey list-of-layers }
            [:attr string]
            { :locref string  [:open-range | :close-range]
            | :xref string-list } )
</PRE>
<HR>
</P>
<P>The pseudo variable <EM>string</EM> is a sequence of characters
surrounded by double quotes, e.g.</P>
<P>
<PRE>
  &quot;Hi, it's me&quot;  &quot;one&quot;  &quot;a string with two \&quot;double quotes\&quot;&quot;
</PRE>
</P>
<P>are three examples of valid strings. If you need to include a
double quote as a literal character, you must quote it itself with a
backslash as shown in the third example. A <EM>string list</EM> is simply
a list of strings separated by whitespaces and surrounded by round
braces. An example of a string list is</P>
<P>
<PRE>
  (&quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;list&quot; &quot;of&quot; &quot;strings&quot;)
</PRE>
</P>
<P>So far about the syntax. The semantics of the different elements are
described here.</P>

<P>
<DL>

<DT><B><CODE>:key</CODE></B><DD><P>The argument <EM>string list</EM> defines the keyword of
the index entry. It must be a list of strings, since the keyword may
consist of different layers such as <CODE>("heap" "fibonacci")</CODE>.</P>

<DT><B><CODE>:print</CODE></B><DD><P>The optional <EM>print key</EM> defines the way the
keyword has to be printed in the markup phase.</P>

<DT><B><CODE>:tkey</CODE></B><DD><P>Another possibility to define the keys of an
index entry is with the <CODE>:tkey</CODE> keyword argument. It can be used
instead of the <CODE>:key</CODE> and <CODE>:print</CODE> arguments. Instead of
specifying separately the key and the corresponding print key, we
define the keyword by its layers. Each layer consist of a list of one
or two strings. The first string will be interpreted as the main key,
whereas the second one will become the print key. If the print key is
ommited, the main key is taken instead. So the definition</P>
<P>
<PRE>
  :tkey ((&quot;This&quot;) (&quot;is&quot;) (&quot;a&quot;) (&quot;bang&quot; &quot;BANG !!!&quot;))
</PRE>
</P>
<P>is equivalent to</P>
<P>
<PRE>
  :key   (&quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;bang&quot;)
  :print (&quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;BANG !!!&quot;)
</PRE>
</P>


<DT><B><CODE>:locref</CODE></B><DD><P>The reference an index entry describes can be a
<EM>location reference</EM> or a <EM>cross reference</EM>. The switch
<CODE>:locref</CODE> describes a location reference. Its optional arguments
are <CODE>:open-range</CODE> and <CODE>:close-range</CODE>. The <EM>string</EM> that must
be supplied must somehow encode the location reference. It might look
like the string <CODE>"25"</CODE> representing the page number 25, or
<CODE>"Appendix-I"</CODE> representing the first appendix numbered in
uppercase roman numerals.</P>

<DT><B><CODE>:open-range</CODE>,<CODE>:close-range</CODE></B><DD><P>These are switches that do not
take any arguments. They describe the beginning and ending of a
<EM>range</EM>, starting or ending from the location reference that is
given by the argument <CODE>:locref</CODE>. If they are supplied, the
location reference may have influence on the way ranges are build.</P>

<DT><B><CODE>:xref</CODE></B><DD><P>These arguments choose the second alternative. The
argument <EM>string list</EM> of parameter <CODE>:xref</CODE> describes where the
index entry should point to.</P>

<DT><B><CODE>:attr</CODE></B><DD><P>This parameter may be used to tag a location reference
with a certain attribute or it names the class of a cross reference.
It may also used to associate different markup for different
attributes in the markup phase. If this parameter is omitted or is the
empty string, the indexentry is declared to have the attribute
<CODE>default</CODE>.</P>

</DL>
</P>
<P>Some examples:</P>
<P>
<PRE>
  (indexentry :key (&quot;airplane&quot;) :locref &quot;25&quot; :attr &quot;default&quot;)
</PRE>
</P>
<P>defines an index entry with the key `airplane' indexed on page '25'.
This index entry has the attribute <CODE>default</CODE>.</P>
<P>
<PRE>
  (indexentry :key (&quot;house&quot;) :xref (&quot;building&quot;) :attr &quot;see&quot;)
</PRE>
</P>
<P>defines a cross reference with the key 'house' pointing to the term
'building'. This cross reference belongs to the cross reference class
<CODE>see</CODE>.</P>
<P>
<PRE>
  (indexentry :key (&quot;house&quot;) :xref (&quot;building&quot;) :open-range)
</PRE>
</P>
<P>is an invalid specification, since <CODE>:open-range</CODE> mustn't be used
together with cross references.</P>




<HR>
<A HREF="manual-2.html"><IMG SRC="prev.gif" ALT="Previous"></A>
<A HREF="manual-4.html"><IMG SRC="next.gif" ALT="Next"></A>
<A HREF="manual.html#toc3"><IMG SRC="toc.gif" ALT="Contents"></A>
</BODY>
</HTML>
