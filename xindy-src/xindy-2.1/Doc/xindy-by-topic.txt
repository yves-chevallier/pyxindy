  xindy
  A Flexible Indexing System
  Roger Kehr, Computer Science Department, Darmstadt University of
  Technology
  xindy by Topic, Edition February 1998 for xindy version 2.0

  _T_h_e _x_i_n_d_y _b_y _t_o_p_i_c _m_a_n_u_a_l _i_s _i_n_t_e_n_d_e_d _f_o_r _a_l_l _p_r_a_c_t_i_t_i_o_n_e_r_s _t_h_a_t _d_o
  _n_o_t _w_a_n_t _t_o _r_e_a_d _t_o_o _m_u_c_h _a_b_o_u_t _x_i_n_d_y_s _d_e_t_a_i_l_s _b_u_t _r_a_t_h_e_r _s_t_a_r_t _t_o
  _s_o_l_v_e _c_o_n_c_r_e_t_e _p_r_o_b_l_e_m_s _i_m_m_e_d_i_a_t_e_l_y_. _T_h_i_s _i_s _E_d_i_t_i_o_n _F_e_b_r_u_a_r_y _1_9_9_8 _a_n_d
  _d_e_s_c_r_i_b_e_s _t_h_e _f_e_a_t_u_r_e_s _o_f _x_i_n_d_y _v_e_r_s_i_o_n _2_._0_. _T_h_e _m_o_s_t _u_p_-_t_o_-_d_a_t_e _v_e_r_-
  _s_i_o_n _o_f _t_h_i_s _d_o_c_u_m_e_n_t _c_a_n _b_e _o_b_t_a_i_n_e_d _f_r_o_m _t_h_e xindy homepage at
  http://www.iti.informatik.tu-darmstadt.de/xindy/.
  ______________________________________________________________________

  Table of Contents:

  1.      How to ...

  1.1.    I don't want to write style files. How can I proceed?

  1.2.    Eventually, I decided to write my first index style. How can I
  start?

  1.3.    How do I use

  1.4.    Why a completely new indexing tool?

  1.5.    I'm an old

  1.6.    What is

  1.7.    How to write my first index style?

  1.8.    How works

  1.9.    How works the actual key feature of

  1.10.   I want to process an index for my native language. What must I
  do?

  1.11.   In my index the capitalized words appear after the lowercase
  words. Why?

  1.12.   In my index there are no letter groups, yet!

  1.13.   How can I get rid of any formatting information in the
  keyword?

  1.14.   In my index the word

  1.15.   I want to use letter ordering instead of word ordering in my
  index.

  1.16.   My document does not have page numbers, but a different
  scheme. What must I do?

  1.17.   I don't want to have ranges in my index. What can I do?

  1.18.   I want to markup ranges of different length differently. How
  do I accomplish this?

  1.19.   I need to suppress some of the markup tags. How can I do this?

  1.20.   Whats it all about those cross references?


  2.      Practical Tips

  2.1.    What LaTeX-package should I use in conjunction with xindy?

  2.2.    What editor should I use when writing xindy style files?

  2.3.    I have written a module for processing language

  3.      Errors and Problems

  3.1.    The keyword mappings don't work as expected!

  3.2.    I'm totally confused by the markup scheme!

  4.      References
  ______________________________________________________________________

  11..  HHooww ttoo ......

  11..11..  II ddoonn''tt wwaanntt ttoo wwrriittee ssttyyllee ffiilleess.. HHooww ccaann II pprroocceeeedd??


  You can use the wrapper program mmaakkeeiinnddeexx44. It tries to do it's very
  best to make xindy behave as mmaakkeeiinnddeexx does. But if you ever need to
  use some of the features of xindy you should learn how to write an
  index style. Its easy!



  11..22..  EEvveennttuuaallllyy,, II ddeecciiddeedd ttoo wwrriittee mmyy ffiirrsstt iinnddeexx ssttyyllee.. HHooww ccaann II
  ssttaarrtt??


  Congratulations! You have made a good decision, indeed.

  For a first impression, how a style file can be written from scratch
  reference the _t_u_t_o_r_i_a_l that comes with this distribution. It is
  written as a guided step-by-step practicing exercise and you can learn
  the basic concepts quite easily.

  Afterwards, the best starting point is to make a copy of the template
  file that contains all the necessary commands that are needed to make
  a mmaakkeeiinnddeexx-like index. You can find it in the subdirectory mmaarrkkuupp//tteexx
  of the module library. Starting from this template you can remove or
  add commands as necessary.

  Additionally, consult the library of predefined _i_n_d_e_x _s_t_y_l_e _m_o_d_u_l_e_s
  that comes with this distribution. Solutions for most of the typical
  problems can be found there, such as a module for doing case-
  insensitive sorting rules, or a typical TeX-like markup. Most of the
  time is is enough to include some of these modules and add a few
  additional commands.

  Maybe some of the examples coming with the _t_e_s_t_-_s_u_i_t_e are good
  examples of how unusual index style files can be written.

  Thus, there are many ways to learn writing an index style file. But it
  is very easy and after some experience you can process indexes your
  friends will be jealous of.







  11..33..  HHooww ddoo II uussee mmaakkeeiinnddeexx44?


  Process your document as usual. Then run mmaakkeeiinnddeexx44 on the index file.
  It produces an index that should equal the one you would get with an
  ordinary mmaakkeeiinnddeexx run. As far as you are satisfied with the default
  behaviour of mmaakkeeiinnddeexx, mmaakkeeiinnddeexx44 will produce comparable results.

  Some of the command-line options of mmaakkeeiinnddeexx are accepted by
  mmaakkeeiinnddeexx44, others aren't. This may change in future releases, but we
  recommend using plain xindy after a phase of investigation, since one
  cannot use all of its features with mmaakkeeiinnddeexx44. You will be informed
  about unsupported command-line arguments when running mmaakkeeiinnddeexx44.

  If you have written special style files for mmaakkeeiinnddeexx they will no
  longer work with mmaakkeeiinnddeexx44. Go ahead and write a new style file for
  xindy.




  11..44..  WWhhyy aa ccoommpplleetteellyy nneeww iinnddeexxiinngg ttooooll?? mmaakkeeiinnddeexx works fine!


  With the _I_n_t_e_r_n_a_t_i_o_n_a_l _M_a_k_e_I_n_d_e_x project, Joachim Schrod and Gabor
  Herr [3, 6] have shown that adding extensions to mmaakkeeiinnddeexx is a
  difficult job. Thus we have decided to develop a new indexing tool
  from scratch. The new tool is based on a new requirements analysis and
  offers very interesting features for processing very complex indexing
  schemes. The resulting index model is described in [5, 7, 8].




  11..55..  II''mm aann oolldd mmaakkeeiinnddeexx wizard. What does xindy offer that mmaakkeeiinn--
  ddeexx doesn't?


  Here are the most important differences between xindy and mmaakkeeiinnddeexx:




     IInntteerrnnaattiioonnaalliizzaattiioonn
        xindy can be configured to process indexes for many languages
        with different letter sets and different sorting rules. For
        example, many roman languages such as Italian, French,
        Portuguese or Spanish contain accentuated letters such as A, A,
        n. Other languages from northern Europe have letters like Ae,
        OE, ae or ss which often can't be processed by many index
        processors not talking about sorting them correctly into an
        index. The xindy-system can be configured to process these
        alphabets by defining _s_o_r_t and _m_e_r_g_e_-_r_u_l_e_s that allow expressing
        of language specific rules.  One example of such a rule would be


        (sort-rule '' 'ae')



     defining that a word containing the umlaut-a will be sorted as if
     it contained the letters aaee instead. This is one form of how the
     umlaut-a is sorted into german indexes. With an appropriate set of
     rules one can express the complete rules of a specific language.


     LLooccaattiioonn ccllaasssseess..
        mmaakkeeiinnddeexx is able to recognize and process arabic numbers, roman
        numerals and letter-based alphabets as specifiers for the
        indexed location. Simple composite structures of these are also
        possible to process. This implicit recognition scheme has
        completely been dropped in favour of a well-defined and very
        powerful declaration scheme called _l_o_c_a_t_i_o_n_-_c_l_a_s_s_e_s. Thus, xindy
        initally does not know any location-class by default and must be
        instructed to accept certain location-classes. A typical
        declaration might look like:



          (define-location-class "page-numbers" ("arabic-numbers"))




     This declares that page numbers consist of the enumeration of the
     arabic numbers. The arabic numbers are referred to as _a_l_p_h_a_b_e_t_s.
     Users may use the pre-defined alphabets arabic numbers, roman
     numerals, etc. or define new alphabets as needed. See the tutorial
     that comes with this distribution for some examples.


     TThhee ccoonncceepptt ooff aattttrriibbuutteess..
        With mmaakkeeiinnddeexx one can assign a markup to each index entry using
        the encapsulators (usually following the vertical bar sign in an
        index entry command). For example in the specification



          \index{xindy|bold}




     the encapsulator is bboolldd which encapsulates the page-numbers in the
     markup-phase. An additional TeX-macro must be supplied to assign
     some markup with the page number. This concept has completely been
     dropped in xindy in favour of a more powerful scheme called
     _a_t_t_r_i_b_u_t_e_s. Attributes can be used to (i) define several grouping
     and ordering rules with locations and we can define (ii) markup-
     tags for the document preparation system.

     The result of this design decision is that the user is required to
     define the attributes in the style file and not in the document
     preparation system. The reasons lie in the more powerful markup
     scheme of xindy which can't be specified in the document processor
     anymore.  In fact, the mmaakkeeiinnddeexx-like markup is only a small subset
     of xindys features.


     CCrroossss rreeffeerreenncceess..
        Cross-references were implemented in mmaakkeeiinnddeexx with the
        encapsulation mechanism, which only served for markup purposes.
        This has been completely separated in xindy.  Here we
        distinguish cleanly between attributes and cross references.
        This makes it possible to implement _c_h_e_c_k_e_d cross references,
        i.e. cross-refernces that can be checked if they point to an
        existing index entry instead of somewhere ``behind-the-moon''.


     LLeessss ccoommmmaanndd--lliinnee ooppttiioonnss..
        xindy has dropped the usage of command-line options in favour of
        a well-defined indexstyle description language. Thus, options
        that could be activated at the command-line level of mmaakkeeiinnddeexx
        must now be specified in the indexstyle file. This sounds more
        restrictive than it is, because the indexstyle files can be
        composed from several modules which makes it possible to write
        style files in just a few lines of code.


     RRaaww iinnddeexx ppaarrsseerr..
        The parser built into mmaakkeeiinnddeexx has completely been separated
        from the core xindy system. xindy understands a well-defined
        specification language for the raw index that is completely
        different from mmaakkeeiinnddeexx, but in our opinion more maintainable
        than the mmaakkeeiinnddeexx format. This requires a separate filter that
        transforms arbitrary indexes to the xindy format. An example
        filter is the program tteexx22xxiinnddyy that comes with this
        distribution.


  Summed up, some of the implicit assumptions made by mmaakkeeiinnddeexx have
  been replaced and now burdend to the user. The reason is that many of
  mmaakkeeiinnddeexx's assumptions were no longer valid in multi-language
  environments or documents with arbitrary location structures. This
  also characterizes xindy more as a framework instead of a end-user-
  tailored product. One should notice that writing an appropriate index
  style is an essential part of the document preparation process and
  should be tailored to each document anew.




  11..66..  WWhhaatt iiss tteexx22xxiinnddyy?


  tteexx22xxiinnddyy is a filter that parses `..iiddxx' or similar files and converts
  the indexentry macros into a form readable by xindy.

  The parser of mmaakkeeiinnddeexx can be configured to recognize different
  quoting characters, etc. (see the man-page for mmaakkeeiinnddeexx, section
  _i_n_p_u_t _s_t_y_l_e _s_p_e_c_i_f_i_e_r_s for further details). We have tried to extract
  the parser from mmaakkeeiinnddeexx but due to several probems we have finally
  rewritten the parser using lleexx. Scanners written with lleexx are usually
  fixed to a specific character set used in the regular expressions. Our
  parser, tteexx22xxiinnddyy is therefore not configurable. If one uses a
  different configuration of the mmaakkeeiinnddeexx input style specifiers, one
  can change the source (tteexx22xxiinnddyy..ll) to generate a completely new
  parser. From our personal experience we have rarely used more than two
  different parsers in practice so we have written tteexx22xxiinnddyy in a form
  that is easily maintainable. The input specifiers are stored
  symbolically in the source. The definiton section looks like this:



       KEYWORD  \\indexentry
       ENCAP    \|
       ACTUAL   @
       ESCAPE   \\
       LEVEL    !
       QUOTE    \"
       ROPEN    \(
       RCLOSE   \)
       ARGOPEN  \{
       ARGCLOSE \}




  These definitions are essentially the input style specifiers as can be
  found in the man-page of mmaakkeeiinnddeexx. Changing this section according to
  your needs and recompiling tteexx22xxiinnddyy should be an easy task. Maybe we
  will include more pre-defined parsers in future releases if necessary.





  11..77..  HHooww ttoo wwrriittee mmyy ffiirrsstt iinnddeexx ssttyyllee??


  Copy the file tteexx//mmaakkeeiiddxx..xxddyy from the library to your local
  directory. It is documented in in a way that should make it easy to
  fill in new commands or remove or modify others.



  11..88..  HHooww wwoorrkkss mmaakkeeiinnddeexx44?


  This job is now done automatically by mmaakkeeiinnddeexx44. It calls tteexx22xxiinnddyy
  to transform the raw-index into the format suitable for xindy.
  tteexx22xxiinnddyy emits some information about the attributes (aka.
  encapsulators in mmaakkeeiinnddeexx) and the usage of cross-references into a
  file, which has the extension `..ssttaa'. The mmaakkeeiinnddeexx44 program, written
  in ppeerrll, parses this statistics-file and generates the above presented
  indexstyle commands for you automatically including the required
  declaration of all attributes in the whole index and their markup.

  Another problem is the automatic detection of cross-references. As
  noted above, mmaakkeeiinnddeexx handles cross-references with its encapsulation
  mechanism, a scheme which has been dropped in xindy and replaced by a
  more powerful mechanism. To implement a simple plug-in mechanism we
  have extended the syntax of the tteexx22xxiinnddyy filter to identify
  encapsulators of the form



       \indexentry{...|encap{...}}{...}




  as a cross-reference, whereas encapsulators of the form



       \indexentry{...|encap}{...}




  are treated as ordinary attributes. This is standard practice defining
  cross-references in mmaakkeeiinnddeexx. Thus, tteexx22xxiinnddyy distinguishes these two
  forms of encapsulators as opposed to mmaakkeeiinnddeexx and our plug-in
  mmaakkeeiinnddeexx44 generates the appropriate definitions of the cross-
  reference classes as well.








  11..99..  HHooww wwoorrkkss tthhee aaccttuuaall kkeeyy ffeeaattuurree ooff mmaakkeeiinnddeexx with xindy?


  The treatment of the actual key (usually denoted with @@, the at-sign)
  has changed with xindy. Specifying index entries with a specific
  markup can be done in mmaakkeeiinnddeexx with the actual key. The mmaakkeeiinnddeexx--33
  system and xindy offer the _m_e_r_g_e_- and _s_o_r_t_-_r_u_l_e_s to transform a key
  into different representations, limiting the need to specify an actual
  key. For example they support a style of writing



       \index{\bf{VIP}}




  which can be transformed with a rule like



       (merge-rule "\bf{\(.*\)}" "\1" :again :bregexp)




  which removes the macro definition for merging and sorting keywords,
  but keeping the original definition for markup purposes. Therefore we
  don't need any actual keys for all keywords written in boldface.

  The mmaakkeeiinnddeexx behaviour, that the two keywords



       \index{VIP}
       \index{VIP@\bf{VIP}}




  are seen as two distinct index entries, can be simulated using the
  following definition:



       (merge-rule "\bf{\(.*\)}" "\1~e" :again :bregexp)




  This rule tells xindy to remove the boldface macro for merging and
  sorting purposes but defines the replacement to include the special
  character ~e, which is the last character in the alphabet (ISO-Latin
  in our case). This makes xindy treat them as different keywords and
  positions the boldface keyword right behind the one without any
  markup. Thus we receive the following mapping:



       Keyword:    Merged and sorted as:   Appears in the index as:
       VIP              VIP                     VIP
       \bf{VIP}         VIP~e                   \bf{VIP}




  With this new style of writing keywords and defining their markup, the
  need to explicitly specifying the print key (aka. actual key) has
  convinced us to remove the mmaakkeeiinnddeexx way of defining keywords.




  11..1100..  II wwaanntt ttoo pprroocceessss aann iinnddeexx ffoorr mmyy nnaattiivvee llaanngguuaaggee.. WWhhaatt mmuusstt II
  ddoo??


  What makes mmaakkeeiinnddeexx hardly usable in non-English speaking countries
  is its lack of support of language specific alphabets and sort
  orderings. For example, many roman languages such as Italian, French,
  Portuguese or Spanish contain accented letters such as A, A, n. Other
  languages from northern Europe have letters like Ae, OE, ae or ss
  which often can't even be processed by many index processors let alone
  sorting them correctly into an index.

  Two problems must be solved when processing indexes with a new
  languages:


  1. The _s_o_r_t _o_r_d_e_r_i_n_g of the indexed terms must be specified in an
     appropriate manner. This problem can be solved using the so-called
     _k_e_y_w_o_r_d _m_a_p_p_i_n_g_s.

  2. The _l_e_t_t_e_r _g_r_o_u_p_s that partition the indexed terms into separate
     sections must be specified.

  The xindy system can be configured to process these alphabets by
  defining _s_o_r_t and _m_e_r_g_e _r_u_l_e_s that allow expressing language specific
  rules.

  The keyword mappings are as follows: The _m_e_r_g_e _k_e_y is generated from
  the _m_a_i_n _k_e_y with the so called _m_e_r_g_e _m_a_p_p_i_n_g. The merge mapping can
  be specified with the command mmeerrggee--rruullee. The _s_o_r_t _k_e_y is derived from
  the merge key using the _s_o_r_t _m_a_p_p_i_n_g specified with the ssoorrtt--rruullee
  command. The following scheme shows this mapping process:

  key -> merge key -> sort key

  The index style commands accomplishing this task are ssoorrtt--rruullee and
  mmeerrggee--rruullee. One example of such a rule would be



       (sort-rule "" "ae")




  defining that a word containing the umlaut-a will be sorted as if it
  contained the letters aaee instead. This is one form of how the umlaut-a
  () is sorted into german indexes. With an appropriate set of rules on
  can express the complete rules of a specific language.

  An example of how an appropriate mapping for some of the Roman
  languages could look like is:







  (sort-rule "" "a")
  (sort-rule "" "a")
  (sort-rule "" "a")
  (sort-rule "" "e")
  (sort-rule "" "e")
  (sort-rule "" "c")




  This makes the accented letters be sorted as their unaccented
  counterparts, yielding the desired sort ordering.

  Sometimes it is necessary to specify keyword mappings that tell the
  system to put something _b_e_h_i_n_d something else. For instance, we'd like
  to map the character  behind the letter _o. No problem if you use the
  special characters ~b and ~e which are called the _b_e_g_i_n_n_i_n_g and _e_n_d_i_n_g
  characters. The first letter lexicographically precedes all other
  letters whereas the latter one comes after all others. Our mapping
  problem can now be specified as follows.



       (sort-rule "" "o~e")




  Now the  is directly positioned after the _o but before _p.


  See the manual for a detailed description of this feature.  Also be
  informed that the keyword mappings can be specified with regular
  expressions. Rules of the form



       (merge-rule "[-$()]" "")




  are possible. This on removes all letters of the defined letter class.
  Regular expression substitutions are possible as well. Refer to the
  manual for an exact description.





  11..1111..  IInn mmyy iinnddeexx tthhee ccaappiittaalliizzeedd wwoorrddss aappppeeaarr aafftteerr tthhee lloowweerrccaassee
  wwoorrddss.. WWhhyy??


  The default sort ordering sorts letters according to their ordinal
  number in the ISO Latin alphabet. As a consequence the lowercase
  letters appear before the uppercase letters. To sort them case-
  insensitively use the command



       (require "lang/latin/caseisrt.xdy")




  This module defines the appropriate sort rules for the letters `A-Z'
  for latin-based alphabets. If your language has more letters simply
  add the missing ones into your style file. Have a look at the module
  to see how to the sort rules are defined.




  11..1122..  IInn mmyy iinnddeexx tthheerree aarree nnoo lleetttteerr ggrroouuppss,, yyeett!!


  Letter groups for latin based alphabets can be defined with the
  command



       (require "lang/latin/letgroup.xdy")




  If your language needs additional letter groups you can insert them
  into the previously defined letter group with inserting definitions of
  the following form:



       (define-letter-group "ly" :after "l" :before "m")
       (define-letter-group "ny" :after "n" :before "o")




  This adds two more letter groups to the latin alphabet. Group _l_y is
  inserted between _l and _m, and _n_y is inserted between _n and _o. This is
  how two additional letters of the Hungarian alphabet can be inserted.




  11..1133..  HHooww ccaann II ggeett rriidd ooff aannyy ffoorrmmaattttiinngg iinnffoorrmmaattiioonn iinn tthhee kkeeyywwoorrdd??


  Assume you have index entries containing arbitrary formatting
  information. For example you write your index entries in TeX in the
  following form:



       \index{\bf{In boldface please}}




  To avoid specifying for each index entry the print key separately as
  can be done with the following command



       \index{In boldface please@\bf{In boldface please}}




  you can instead define a rule doing this task for you:

       (merge-rule "\\bf *{(.*)}" "\1" :eregexp :again)




  This extended regular expression matches all strings that are
  surrounded by this formatting command and in the _m_e_r_g_e _p_h_a_s_e the
  formatting command is simply stripped off. Thus, you don't need to
  write an explicit print key anymore.

  If for some reason the same word appears more than once in the index,
  each time having another markup tag as in the following example



       index
       {\tt index}




  you must be warned that a rule like



       (merge-rule "{\\tt *(.*)}" "\1" :eregexp :again)




  is probably not correct. In this case the above strings are both
  mapped into the string iinnddeexx thus joining their location references
  into one index entry. This happens because the result of the merge
  mapping is used as the equality citerium which views both keywords as
  equal. To avoid this you should specify instead



       (merge-rule "{\\tt *(.*)}" "\1~e" :eregexp :again)




  With the additional meta character ~e the substitution of the second
  key word is placed _a_f_t_e_r the first one making them different index
  entries. If the second keyword should appear first, use ~b instead.





  11..1144..  IInn mmyy iinnddeexx tthhee wwoorrdd _-_f_o_o aappppeeaarrss bbeeffoorree _b_a_r.. WWhhaatt mmuusstt II ddoo??


  Especially for hierarchical indexes sometimes the result is not as
  expected due to special characters appearing in the keyword. In the
  following example the word `card' should appear before `-eyed' since
  the hyphen should not count as an ordinary character by means of
  sorting.



         green
            -eyed  12
            card   15

  This is especially problematic if the list of words on the second
  level is very long. To make the hyphen be simply ignored during the
  sorting process you should specify the following command in the index
  style:



         (sort-rule "-" "")




  This makes `-eyed' be sorted as `eyed' thus making it appear _a_f_t_e_r
  `card' as desired.





  11..1155..  II wwaanntt ttoo uussee lleetttteerr oorrddeerriinngg iinnsstteeaadd ooff wwoorrdd oorrddeerriinngg iinn mmyy
  iinnddeexx..


  According to the _C_h_i_c_a_g_o _M_a_n_u_a_l _o_f _S_t_y_l_e there exist two different
  schemes of sorting word lists. In _w_o_r_d _o_r_d_e_r_i_n_g a blank precedes any
  letter in the alphabet, whereas in _l_e_t_t_e_r _o_r_d_e_r_i_n_g it does not count
  at all. The following example borrowed from the mmaakkeeiinnddeexx man-page
  illustrates the difference:



        Word Order:         Letter Order:
         sea lion            seal
         seal                sea lion




  By default, xindy uses word ordering. To use letter ordering include
  the appropriate module with the following command:



       (require "ord/letorder.xdy")




  It actually defines the following command:



       (sort-rule " " "")




  This simply removes all blanks from the keyword resulting in the
  desired behaviour.







  11..1166..  MMyy ddooccuummeenntt ddooeess nnoott hhaavvee ppaaggee nnuummbbeerrss,, bbuutt aa ddiiffffeerreenntt sscchheemmee..
  WWhhaatt mmuusstt II ddoo??


  The ability to deal with user-definable location structures is one of
  the most important new features of xindy. Many documents have a
  document structure that is not based on page numbers. Typical examples
  are manuals or appendices that come with a _c_h_a_p_t_e_r_/_p_a_g_e_-_p_e_r_-_c_h_a_p_t_e_r
  numbering scheme, URLs, Bible verses, etc. One can even imagine the
  Greek alphabet as possibly appearing in a location reference. In our
  analysis we have found many interesting examples of location
  references that made us to develop the concept of _l_o_c_a_t_i_o_n _c_l_a_s_s_e_s.

  A location class is defined by a sequence of alphabets. An alphabet
  can be the set of arabic numbers (0, 1, 2, ...) or the roman numerals
  (i, ii, iii, ...). These are built-in alphabets in xindy.
  Addtionally, one can define more alphabets in the index style with a
  command like


    (define-alphabet "weekdays"
           ("mon" "tue" "wed" "thu" "fri" "sat" "sun"))



  Based on alphabets one can now compose a location class as follows:


    (define-location-class "weekday-hours"
           ("weekday" :sep ":" "arabic-numbers"))



  This class description indicates that all location refernces matching
  this template are viewed as correct instances of this class. Here ::sseepp
  makes the dot serving as a _s_e_p_a_r_a_t_i_o_n _s_t_r_i_n_g separation the alphabets
  from each other. Example instances of this class are:


  mon:23, thu:45, sun:17



  For more detailed information consult the description of the command
  ddeeffiinnee--llooccaattiioonn--ccllaassss in the reference manual.




  11..1177..  II ddoonn''tt wwaanntt ttoo hhaavvee rraannggeess iinn mmyy iinnddeexx.. WWhhaatt ccaann II ddoo??


  By default, xindy joins three successive location references into a
  _r_a_n_g_e. Ranges are used as an abbrevation for a long sequence of
  location references. For exmaple the sequence


  12, 13, 14, 15, 16



  would be shorter represented as


  12-16

  If you don't want to have ranges, simply define your location class in
  the form


    (define-location-class ... :min-range-length none)



  The argument ::mmiinn--rraannggee--lleennggtthh nnoonnee avoids forming of ranges.
  Arbitrary numbers instead of nnoonnee define the minimum length of a
  sequence of location references that are needed to form a range.
  xindys default value is 2.




  11..1188..  II wwaanntt ttoo mmaarrkkuupp rraannggeess ooff ddiiffffeerreenntt lleennggtthh ddiiffffeerreennttllyy.. HHooww ddoo
  II aaccccoommpplliisshh tthhiiss??


  A common way of tagging ranges is as follows: a range of length 1 is
  printed with the starting page number and the suffix `f.', those of
  length 2 with suffix `ff.', and all others in the form `_X_-_-_Y'.

  Assume we want to do this for the location class _p_a_g_e_n_u_m_s we can
  specify the markup as follows:



       (markup-range :class "pagenums" :close "f."  :length 1 :ignore-end)
       (markup-range :class "pagenums" :close "ff." :length 2 :ignore-end)
       (markup-range :class "pagenums" :sep "--")




  The first command indicates that a range _(_X_,_Y_) of length 1 should be
  printed in the form _X_f_., a range of length 2 as _X_f_f_. and all others in
  the form _X_-_-_Y. The switch ::iiggnnoorree--eenndd causes the end of range location
  reference Y to be suppressed in the resulting output.



  11..1199..  II nneeeedd ttoo ssuupppprreessss ssoommee ooff tthhee mmaarrkkuupp ttaaggss.. HHooww ccaann II ddoo tthhiiss??

  Sometimes it is necessary to hide some of the parts of the index. If
  you have a text formatter that allows comments or macros that possibly
  expand to nothing, just define appropriate markup that makes things
  invisible to the formatter. For example, with TeX you can define a
  macro like this



       \def\ignore#1{}




  If you additionally define markup like this



       (markup-index :open "\ignore{" :close "}")



  you can throw away the complete index if you like, which would be a
  real pity!




  11..2200..  WWhhaattss iitt aallll aabboouutt tthhoossee ccrroossss rreeffeerreenncceess??


  Cross references are references pointing to an item in the index
  itself. Typical examples are:


       foo-bar _s_e_e baz


  With mmaakkeeiinnddeexx cross references could be specified with the
  encapsulation mechanism. This has completely been removed in xindy and
  we have made cross references real first-class objects.

  In xindy one can declare different cross reference classes, whose
  purpose is (a) to make all instances of a certain class appear next to
  each other, and (b) to specify appropriate markup with them.

  @begin-comment One very interesting feature is the ability to _c_h_e_c_k
  the validity of cross-references.  @end-comment

  tteexx22xxiinnddyy recognises all index entries of the form


    \index{...|\macro{where}}



  as cross references. Here mmaaccrroo stands for an arbitrary macro name and
  wwhheerree is interpreted as the target keyword of the cross references.

  If you want to use these cross references with xindy; add the
  following line to your style file.


    (define-crossref-class "macro")



  Additionally, you can assign specific markup to cross references using
  the mmaarrkkuupp--ccrroossssrreeff-commands.





  22..  PPrraaccttiiccaall TTiippss

  22..11..  WWhhaatt LLaaTTeeXX--ppaacckkaaggee sshhoouulldd II uussee iinn ccoonnjjuunnccttiioonn wwiitthh xxiinnddyy??


  We strongly recommend using the LaTeX2e-package iinnddeexx written by David
  M. Jones, which is available at CTAN. It supports multiple indexes as
  well as several shortcuts to easily index terms in a document.
  Multiple indexes support the generation of several indexes for one
  document. For instance, one can make an author or command index in
  addition to a global index.

  Another option is to use the xxiinnddyy..ssttyy from Andreas Schlechte that
  comes with the xindy distribution. Take a look at the ccoonnttrriibb
  directory that should contain a version.


  22..22..  WWhhaatt eeddiittoorr sshhoouulldd II uussee wwhheenn wwrriittiinngg xxiinnddyy ssttyyllee ffiilleess??


  Use EEmmaaccss or XXEEmmaaccss. Turn on the Lisp-mode with



       M-x lisp-mode




  and you can properly indent commands using MM--qq. To enter this mode
  automatically add the following lines to the end of the style file:



       ^L
       ;; Local Variables:
       ;; mode: lisp
       ;; End:




  The ^L (Control-L) can be entered with CC--qq CC--ll.



  22..33..  II hhaavvee wwrriitttteenn aa mmoodduullee ffoorr pprroocceessssiinngg llaanngguuaaggee _f_o_o_l_a_n_d_i_c.. WWhhaatt
  mmuusstt II ddoo??


  Great! Send it to us! It will become a part of the system in the next
  release.








  33..  EErrrroorrss aanndd PPrroobblleemmss

  33..11..  TThhee kkeeyywwoorrdd mmaappppiinnggss ddoonn''tt wwoorrkk aass eexxppeecctteedd!!


  Sometimes the keyword mappings don't work as expected. Especially in
  cases with several regular expressions one might get confused about
  what rule matches exactly when. We have incorporated a detailed
  logging mechanism that lets one step by step follow the rules that
  accomplish the keyword mapping.

  When running xindy you can turn on this feature with the command line
  option `--LL'. This option followed by one of the numbers 1, 2, or 3
  turns on the appropriate debugging level. Turning on level 2 or 3 and
  specifying a log-file with the command line option `--ll' a trace of the
  mappings is recorded in the log-file. A sample output looks like the
  following:



  Mappings: (add (merge-rule :eregexp `^\\bf{(.*)}' `\1' :again)).
  Mappings: (add (merge-rule :eregexp `^\\"([AEOUaeou])' `\1')).
   ...
  Mappings: (compare `\"A\"a' :eregexp `^\\bf{(.*)}')
  Mappings: (compare `\"A\"a' :eregexp `^\\"([AEOUaeou])') match!
  Mappings: (compare `\"a' :eregexp `^\\bf{(.*)}')
  Mappings: (compare `\"a' :eregexp `^\\"([AEOUaeou])') match!
  Mappings: (merge-mapping `\"A\"a') -> `Aa'.




  This trace shows that initially two regular expression mappings have
  been added to the rule set. The second section shows how the keyword `
  applied as matches are found. In the last line the result of the
  keyword mapping is reported.



  33..22..  II''mm ttoottaallllyy ccoonnffuusseedd bbyy tthhee mmaarrkkuupp sscchheemmee!!


  A very important feature is the ability to _t_r_a_c_e all markup tags xindy
  emits in the markup phase. Simply use the command line switch --tt or
  insert the command



       (markup-trace :on)




  into the index style. This informs xindy to emit additional pseudo
  markup that can be used to understand and debug the markup phase. An
  example output might look like the following:



       <INDEX:OPEN>
         <LETTER-GROUP-LIST:OPEN>
           <LETTER-GROUP:OPEN ["a"]>
             <INDEXENTRY-LIST:OPEN [0]>
               <INDEXENTRY:OPEN [0]>
                 <KEYWORD-LIST:OPEN [0]>
                   <KEYWORD:OPEN [0]>
        ...




  The symbolic tags directly lead one to the command that is responsible
  for the definition of that markup tag. For example, the tag LETTER-
  GROUP-LIST:OPEN indicates that the command markup-letter-group-list is
  responsible for replacing this symbolic tag by a real one.  Give it a
  try if you find yourself confused by your own markup specification.










  44..  RReeffeerreenncceess


  The following books and papers were referenced in this document:


  1. D. E. Knuth, _T_h_e _T_e_X_b_o_o_k, Addison-Wesley, 1984

  2. Leslie Lamport, LaTeX _A _D_o_c_u_m_e_n_t _P_r_e_p_a_r_a_t_i_o_n _S_y_s_t_e_m, Addison-
     Wesley, 1986

  3. Joachim Schrod, _A_n _I_n_t_e_r_n_a_t_i_o_n_a_l _V_e_r_s_i_o_n _o_f _M_a_k_e_I_n_d_e_x, Cahiers
     GUTenberg, 10, p81-90, 1991

  4. Pehong Chen and Michael A. Harrison, _A_u_t_o_m_a_t_i_n_g _I_n_d_e_x _P_r_e_p_a_r_a_t_i_o_n,
     TR-87/347, University of California Berkeley, 1987


  5. Roger Kehr, xindy _E_i_n _F_l_e_x_i_b_l_e_s _I_n_d_e_x_i_e_r_u_n_g_s_s_y_s_t_e_m, Studienarbeit
     FB Informatik, TH-Darmstadt, November 1995.

  6. Joachim Schrod and Gabor Herr, _M_a_k_e_I_n_d_e_x _V_e_r_s_i_o_n _3_._0, Technical
     University of Darmstadt, 1991

  7. Roger Kehr, xindy -- _A _F_l_e_x_i_b_l_e _I_n_d_e_x_i_n_g _S_y_s_t_e_m, Technical Report
     No. 11/1997, Computer Science Department, Darmstadt University of
     Technology, 1997. Also accessible from the xindy homepage.

  8. Roger Kehr, xindy -- _A _F_l_e_x_i_b_l_e _I_n_d_e_x_i_n_g _S_y_s_t_e_m, Proceedings of the
     EuroTeX'98, St. Malo, France, March 1998




































