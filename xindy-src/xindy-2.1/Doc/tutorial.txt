  xindy
  A Flexible Indexing System
  Roger Kehr, Institut fr Theoretische Informatik, TH-Darmstadt
  Tutorial, Edition March 1997 for xindy version 1.1

  _T_h_i_s _i_s _a _t_u_t_o_r_i_a_l _f_o_r _t_h_e _x_i_n_d_y _i_n_d_e_x_i_n_g _s_y_s_t_e_m _[_5_]_. _x_i_n_d_y _i_s _a _g_e_n_-
  _e_r_a_l _p_u_r_p_o_s_e _i_n_d_e_x _p_r_o_c_e_s_s_o_r _t_h_a_t _c_a_n _b_e _c_o_n_f_i_g_u_r_e_d _f_o_r _a _v_a_r_i_e_t_y _o_f
  _d_o_c_u_m_e_n_t _p_r_e_p_a_r_a_t_i_o_n _s_y_s_t_e_m_s_. _W_e _w_i_l_l _d_e_m_o_n_s_t_r_a_t_e _s_t_e_p _b_y _s_t_e_p _t_h_e
  _i_n_c_r_e_m_e_n_t_a_l _s_p_e_c_i_f_i_c_a_t_i_o_n _o_f _a _c_o_m_p_l_e_t_e _i_n_d_e_x _s_t_y_l_e_. _T_h_e _e_x_a_m_p_l_e_s _a_r_e
  _b_a_s_e_d _o_n _i_n_d_e_x_e_s _t_h_a_t _a_r_e _d_e_l_i_v_e_r_e_d _w_i_t_h _t_h_e _s_y_s_t_e_m _s_o _o_n_e _c_a_n _g_e_t
  _a_c_q_u_a_i_n_t_e_d _w_i_t_h _i_t _p_r_a_c_t_i_c_a_l_l_y_.
  ______________________________________________________________________

  Table of Contents:

  1.      About

  2.      A Basic Introduction

  2.1.    Running

  2.2.    Adding some Markup

  2.3.    Keyword Mappings

  2.4.    Letter Groups

  3.      Advanced Features

  3.1.    Location Classes

  3.2.    Hierarchical Location Classes

  3.3.    More about Letter Groups

  4.      References
  ______________________________________________________________________

  11..  AAbboouutt xindy

  xindy means flexxible iinnddexing syystem. It is an indexing system that
  can be used to generate book-like indexes for arbitrary document
  preparation systems. This term includes systems such as TeX [1] and
  LaTeX [2], the Nroff-family or SGML-based systems (e.g. HTML) that
  process some kind of text and generate indexing information. It is not
  fixed to any specific system, but can be configured for a wide variety
  of purposes.

  Authors sometimes wish to include an index into their document, but
  very often their document preparation systems aren't able to produce
  indexes on their own, or the capabilities of the built-in indexers are
  insufficient and produce ugly looking results. More often they use
  separate specialized tools for this purpose, sometimes called _i_n_d_e_x
  _p_r_o_c_e_s_s_o_r_s.

  In comparison to other index processors xindy has several powerful
  features that make it an ideal framework for describing and generating
  complex indexes. Its most interesting features are



     IInntteerrnnaattiioonnaalliittyy
        xindy can be configured to process indexes for many languages
        with different letter sets and different sorting rules. For
        example, many roman languages such as Italian, French,
        Portuguese or Spanish contain accentuated letters such as A, A,
        n. Other languages from northern Europe have letters like Ae,
        OE, ae or ss which often can't even be processed by many index
        processors let alone sorting them correctly into an index. The
        xindy system can be configured to process these alphabets by
        defining _s_o_r_t and _m_e_r_g_e _r_u_l_e_s that allow expressing language
        specific rules. One example of such a rule would be



          (sort-rule "" "ae")




     defining that a word containing the umlaut-a will be sorted as if
     it contained the letters aaee instead. This is one form of how the
     umlaut-a ("") is sorted into german indexes. With an appropriate
     set of rules on can express the complete rules of a specific
     language.


     UUsseerr DDeeffiinnaabbllee LLooccaattiioonn TTyyppeess
        Locations are the entities an index entry points to. Often used
        locations are _p_a_g_e _n_u_m_b_e_r_s, _s_e_c_t_i_o_n _n_u_m_b_e_r_s, etc. xindy allows
        to define new kinds of types to be composed of basic entities
        like arabic numbers, roman numerals, letters, etc. which can be
        used to describe new index types.  Examples of these entities
        can be books that have a page numbering scheme that starts from
        1 for each new chapter resulting in page numbers of the form
        _1_-_1_3_, _2_-_1_5_, _2_-_2_0, etc. This type of locations can often be found
        in computer manuals. A more complex structure is represented by
        the locations _P_s_a_l_m _4_6_, _1_-_8 and _G_e_n_e_s_i_s _1_, _3_1. Even the
        structure of bible verses can be described allowing xindy to
        correctly sort and process indexes for documents with a
        completely different structure.


     HHiigghhllyy CCoonnffiigguurraabbllee MMaarrkkuupp
        Since a index processor is only one component in a document
        preparation system it ought to fit smoothly into the complete
        environment. Many text processing systems use the concept of
        _e_n_v_i_r_o_n_m_e_n_t_s that can be used to describe the markup of the text
        entities. Our approach is based on this concept which has proved
        to be expressive enough for most applications. As an example one
        can view systems such as TeX, SGML and its instance HTML, GNU
        Info, RTF and the Nroff-familiy of document formatters. The
        markup of an index can be defined for all of these systems in a
        very comfortable though extremly powerful way.





  22..  AA BBaassiicc IInnttrroodduuccttiioonn

  This section incrementally introduces the most important aspects of
  the system. After reading this chapter you should be able to specify
  about 80% of the commonly used indexes. The examples are demonstrated
  with a TeX markup so one can easily typeset the results xindy
  produces. You need LaTeX2e and the ISO-Latin enhancements that come
  with the iinnppuutteenncc package to run the following examples. Also the
  xindy system must already be installed.




  22..11..  RRuunnnniinngg xindy

  Create a new directory somewhere and copy some files from the
  distribution directory DDoocc//ttuuttoorriiaall// by typing



       eg$ mkdir tutorial
       eg$ cd tutorial
       eg$ cp <distrib-dir>/Doc/tutorial/*.raw .
       eg$ cp <distrib-dir>/Doc/tutorial/*.tex .




  with ddiissttrriibb--ddiirr replaced by the actual location. Now create a file
  ssttyyllee11..xxddyy with the following content:



       ;; This is a first example using `xindy'.

       (define-location-class "page-numbers" ("arabic-numbers"))
       (define-attributes (("definition" "usage")))




  Now run xindy by typing (the switch `--ll' is the lowercase letter `L')



       eg$ xindy -l ex1.xlg style1.xdy ex1.raw




  You should see something like



       This is `xindy' version 1.1 January 1997 (some-arch).

       Opening logfile "ex1.xlg" (done)
       Reading indexstyle...
       Loading module "style1.xdy"...
       Finished loading module "style1.xdy".
       Finished reading indexstyle.
       Finalizing indexstyle... (done)

       Reading raw-index "ex1.raw"...
       Finished reading raw-index.

       Processing index... [10%] [20%] [30%] [40%] [50%] [60%] [70%] [80%] [90%] [100%]
       Finished processing index.

       Writing markup... [10%] [20%] [30%] [40%] [50%] [60%] [70%] [80%] [90%] [100%]
       Markup written into file "ex1.ind".




  xindy has now successfully compiled the index eexx11..rraaww using your index
  style ssttyyllee11..xxddyy. The result is now stored in file eexx11..iinndd. You can
  view this file but currently it only contains an unreadable mix of
  data.
  But now let's come back to our index style. The syntax of the command
  is in a Lisp-like form with lots of braces, looking a little bit
  weird, but you'll soon get used to it. What is the meaning of the two
  commands we specified? The first command informed xindy that we like
  to process page numbers. We do this by defining a new _l_o_c_a_t_i_o_n _c_l_a_s_s
  named ppaaggee--nnuummbbeerrss. The page numbers consist of aarraabbiicc--nnuummbbeerrss as we
  might expect but this is not necessarily true---imagine your page
  numbers consisted of roman numerals instead.  When reading the _r_a_w
  _i_n_d_e_x contained in file eexx11..rraaww xindy checks all locations if they
  match all known location classes. Since in our example the only known
  location class is the class of page numbers which are written using
  arabic digits, all locations will be checked if they are correct page
  numbers.

  The second command tells xindy that we use two types of attributes for
  location references. Most often the locations in an index denote
  different meanings. For example, in mathematical texts one will
  distinguish the _d_e_f_i_n_i_t_i_o_n of a mathematical term from its _u_s_a_g_e.
  Sometimes these are typeset using different font shapes such as _i_t_a_l_i_c
  or font series such as bboollddffaaccee. Each location has an associated
  attribute which, if it is unspecified, defaults to the attribute
  ddeeffaauulltt. With this command you have made these attributes known to the
  system, which makes it possible to assign different markup to these
  attributes later on.



  22..22..  AAddddiinngg ssoommee MMaarrkkuupp

  Until now you haven't seen something exciting, so its time to specify
  some markup. Add the following lines to our index style:



       (markup-index :open  "~n\begin{theindex}~n"
                     :close "~n\end{theindex}~n"
                     :tree)

       (markup-locref :class "page-numbers" :attr "definition"
                      :open  "{\bf " :close "}")

       (markup-locclass-list :open "\quad{}")
       (markup-locref-list :sep ", ")




  Now run xindy again and afterwards LaTeX:



       eg$ xindy -l ex1.xlg style1.xdy ex1.raw
       eg$ latex ex1.tex




  You can view eexx11..ddvvii with your prefered viewer (maybe xxddvvii or
  something else) to get a first impression of your results. Maybe your
  are not satisfied (for sure you aren't), because it still looks very
  confusing. What did the above rules tell xindy? When you view the file
  eexx11..iinndd which is the result xindy generates, you'll recognize some of
  the _m_a_r_k_u_p _t_a_g_s you specified. The following is an excerpt of this
  file:


       \begin{theindex}
         academia\quad{}{\bf 1}acafetado\quad{}{\bf 2}acalmar\quad{}{\bf 4}
         aafro\quad{}{\bf 3}indexflat\quad{}1hierarchical\quad{}2
         veryhierarchical\quad{}3impressive\quad{}4saber\quad{}{\bf 7}
         sabor\quad{}{\bf 8}sabo\quad{}{\bf 6}sbado\quad{}{\bf 5}
       \end{theindex}

                                                               g
                                                               i
                                                               n
  First of all you'll see that the file starts with the string {index}
  and ends with \nd{theindex}.  Additionally some locations aret
  correctly enclosed into a TeX macro that typesets them in shahpe
  boldface, whereas others aren't. The boldface ones are all those
  locations from the raw index that have the attribute ddeeffiinniittiioonn.

  The ::ooppeenn and ::cclloossee keyword arguments each take a string as argument.
  The first one is written to the file when _o_p_e_n_i_n_g an enviroment,
  whereas the latter one _c_l_o_s_e_s an environment. What we have specified
  is the markup for the whole index (which is actually printed only
  once) and the markup for all locations of class ppaaggee--nnuummbbeerrss which own
  the attribute ddeeffiinniittiioonn. Here we have cleanly separated the
  structured markup from the visual one, allowing an easy redefinition
  if we decide, for example, to markup the ddeeffiinniittiioonn-locations in
  italics instead of boldface.

  Some words on _k_e_y_w_o_r_d _a_r_g_u_m_e_n_t_s and _s_w_i_t_c_h_e_s. Keyword arguments such
  as ::ooppeenn or ::cclloossee always take exactly one argument which must be
  positioned right after the keyword separated by a whitespace (a blank
  or a tab-stop). Switches don't take any arguments. For example, ::ttrreeee
  in the command mmaarrkkuupp--iinnddeexx is a switch and thus it does not take an
  argument. We will use this terminology throughout the rest of this
  document.

  The third command caused xindy to insert a horizontal space between
  the keyword and the locations (the TeX command quad{} simply inserts a
  specific horizontal space). The last command caused xindy to separate
  all location references from each other with a comma followed by a
  blank, independently of any location class.

  As you already may have observed, the tilde sign (~) serves as a
  _q_u_o_t_i_n_g _c_h_a_r_a_c_t_e_r.

  We continue specifying markup to get a printable result by adding more
  markup:



       (markup-indexentry :open "~n  \item "           :depth 0)
       (markup-indexentry :open "~n    \subitem "      :depth 1)
       (markup-indexentry :open "~n      \subsubitem " :depth 2)




  This assigns different markup for the different hierarchy layers of
  the indexentries. Our index is hierarchically organized. It contains
  items which themselves contain more sub-items which also might contain
  sub-sub-items. Each layer is started by a different markup which is
  correctly assigned with the ::ddeepptthh keyword argument. The layers are
  numbered by their _d_e_p_t_h starting from zero.

  Now run xindy and TeX again and enjoy your first index. It's easy,
  isn't it! The output eexx11..iinndd looks like the following:


       \begin{theindex}

        \item academia\quad{}{\bf 1}
        \item acafetado\quad{}{\bf 2}
        \item acalmar\quad{}{\bf 4}
        \item aafro\quad{}{\bf 3}
        \item index
           \subitem flat\quad{}1
           \subitem hierarchical\quad{}2
           \subitem very
             \subsubitem hierarchical\quad{}3
             \subsubitem impressive\quad{}4
        \item saber\quad{}{\bf 7}
        \item sabor\quad{}{\bf 8}
        \item sabo\quad{}{\bf 6}
        \item sbado\quad{}{\bf 5}

       \end{theindex}




  Hmm, as you might have seen there are several problems that need
  further investigation. The index contains some Portuguese words that
  are printed correctly but should appear at other positions inside the
  index. For instance, the word _s_b_a_d_o should appear before the word
  _s_a_b_e_r since  must be sorted as if it were simply an _a. The reason why
  these words are not sorted correctly is simple---the accentuated
  letters have codes beyond position 128 in the ISO-Latin alphabet.
  Sorting based on these codes yields this incorrect order.

  What to do? We can define for each of the words containing these
  special characters an explicit _p_r_i_n_t _k_e_y. The print key describes the
  printed representation of the keyword whereas the _k_e_y or _m_a_i_n _k_e_y is
  used for sorting and merging. A very tedious task which is not a very
  clever solution since in a non-english language many many words
  contain these special cases. We follow the way xindy offers: _k_e_y_w_o_r_d_-
  _m_a_p_p_i_n_g_s.


  22..33..  KKeeyywwoorrdd MMaappppiinnggss

  What are keyword mappings for? A good question. I'll try to give some
  answers.


  +o  _M_e_r_g_i_n_g _o_f _d_i_f_f_e_r_e_n_t_l_y _w_r_i_t_t_e_n _w_o_r_d_s. Some text formatting systems
     allow different writings for the same word. For example, TeX can be
     used with ISO-Latin characters as well as with its own character
     sequences. If a document is composed from smaller ones possibly
     written by different authors using different forms of writing the
     index entries, the same terms may happen to be written differently
     and consequently we need a mechanism to identify them as equal.

  +o  _S_p_e_c_i_f_y_i_n_g _t_h_e _s_o_r_t _o_r_d_e_r. As outlined in the previous section it
     is really difficult and error-prone to specify the sort key for
     each keyword explicitly. Sometimes the sort order is even different
     for the type of the document, as it happens in German, where two
     different types of sortings exist, one for everyday indexes and one
     for dictionaries. The sort order actually defines the position of
     arbitrary language-specific letters inside of an index.

  A detailed elaboration of these ideas can be found in the paper _A_n
  _I_n_t_e_r_n_a_t_i_o_n_a_l _V_e_r_s_i_o_n _o_f _M_a_k_e_I_n_d_e_x by Joachim Schrod [3].  It
  describes the ideas that led to modifications on one of the ancestors
  of the xindy system: mmaakkeeiinnddeexx [4].
  The keyword mappings are as follows. The _m_e_r_g_e _k_e_y is generated from
  the _m_a_i_n _k_e_y with the so called _m_e_r_g_e _m_a_p_p_i_n_g. The merge mapping can
  be specified with the command mmeerrggee--rruullee. The _s_o_r_t _k_e_y is derived from
  the merge key using the _s_o_r_t _m_a_p_p_i_n_g specified with the ssoorrtt--rruullee
  command. The following scheme shows this mapping process:

  key -> merge key -> sort key

  We will use this command now to define a suitable sort mapping that
  fits our needs:



       (sort-rule "" "a")
       (sort-rule "" "a")
       (sort-rule "" "a")
       (sort-rule "" "e")
       (sort-rule "" "e")
       (sort-rule "" "c")




  These rules define mappings from a keyword to a _n_o_r_m_a_l_i_z_e_d version. In
  the logfile eexx11..xxllgg these transformations are logged so that one can
  see how these mappings are performed. In this example we do not need
  any mmeerrggee--rruullee but we will see applications in further examples.

  Running xindy and TeXing the result now places the indexentries at the
  right positions.

  The result is now quite satisfying if the index entries weren't
  clumped together that much. We usually want the different index
  entries beginning with the same letter be optically separated from the
  ofhers. This improves readability and there must be a way to
  accomplish this---the _l_e_t_t_e_r _g_r_o_u_p_s.


  22..44..  LLeetttteerr GGrroouuppss

  To group indexentries we must define what indexentries form a group.
  The clustering is done by matching the keywords' prefixes (taken from
  the _s_o_r_t _k_e_y) with a user-defined table of prefixes and define
  appropriate markup that separates the groups from each other. Here it
  goes.



       (define-letter-groups
         ("a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m"
          "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"))

       (markup-letter-group-list :sep "~n\indexspace")




  This defines the given list of letter groups. When forming the letter
  groups, each letter group is checked if it matches a prefix of the
  indexentries' sort key. The longest match assigns the index entry to
  this letter group. If no match was possible the index entry is put
  into group ddeeffaauulltt.

  The result now looks much better than before. You have now learned the
  basic features that you need to specify everyday indexes. In the next
  chapter we'll continue to make you an expert in indexing.
  33..  AAddvvaanncceedd FFeeaattuurreess

  In the following sections you'll learn more about the features of
  xindy. We'll show you how you can define your own location classes,
  specify the letter groups in more detail and bring you close to more
  specfic markup features. After reading this chapter you should be able
  to master about 95% of the commonly used indexes.



  33..11..  LLooccaattiioonn CCllaasssseess

  We continue using a more complex index. Copy the current style to a
  new file (now ssttyyllee22..xxddyy) and run xindy on the raw index eexx22..rraaww by
  typing:



       eg$ cp style1.xdy style2.xdy
       eg$ xindy -l ex2.xlg style2.xdy ex2.raw




  You should see some error messages indicating that something is
  unknown to xindy. What has happend? The messages should be similar to
  the following snapshot:



        ...
       WARNING:
       location-reference "B-5" did not match any location-class! (ignored)
       WARNING:
       location-reference "C-8" did not match any location-class! (ignored)
       WARNING:
       location-reference "iv" did not match any location-class! (ignored)
       WARNING:
       location-reference "ii" did not match any location-class! (ignored)
        ...




  The index contains new, and therefore unknown, location classes. The
  first one has an appendix-like style, whereas the second one seems to
  be lowercase roman numerals. xindy reported, that it doesn't know
  these locations and therefore knows nothing about their internal
  structure. We make them known to the system by adding the following
  commands to the style file.



       (define-location-class "roman-pages" ("roman-numerals-lowercase"))
       (define-location-class "appendices" ("ALPHA" :sep "-" "arabic-numbers"))
       (define-location-class-order ("roman-pages" "appendices"))




  The first command tells xindy that there exist some page numbers that
  are written with roman lowercase letters. The second one defines the
  structure of the appendix locations. They consist of three elements, a
  capital letter, a separator---which is a hyphen in our case---and
  finally an arabic number. To be able to correctly distinguish
  separator strings from the names of the known _b_a_s_e_t_y_p_e_s, the argument
  ::sseepp indicates, that the following is a separator. The last command
  simply says that the locations which are roman numerals shall appear
  before the appendix locations. So far we know three different
  basetypes. The built-in basetypes of xindy are:


     aarraabbiicc--nnuummbbeerrss
        contains all non-negative numbers beginning with zero: 0, 1, 2,
        ....


     rroommaann--nnuummeerraallss--uuppppeerrccaassee, rroommaann--nnuummeerraallss--lloowweerrccaassee
        the roman numerals I, II, III, (IIII/IV), V, ... It contains the
        old and new roman numeral system. Two versions for uppercase and
        lowercase letters are supported.


     AALLPPHHAA, aallpphhaa
        The US-ASCII alphabet letters (uppercase and lowercase letters).


     ddiiggiittss
        the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9 in this order.

  `Fine,', you'll say, `but what if my basetypes are completely
  different?' You're right! But xindy offers you to define your own
  alphabets. For example, you can define a new alphabet by writing



       (define-alphabet "my-personal-alphabet" ("Hi" "ho" "here" "I" "go"))




  This is a valid alphabet that consists of 5 _l_e_t_t_e_r_s. You can now
  define a location class



       (define-location-class "my-personal-class"
           ("my-personal-alphabet" :sep "-" "arabic-numbers"))




  to match all of the following locations: _H_i_-_1_2_, _h_o_-_2_, _h_e_r_e_-_7_0_9_, _I_-_9_,
  _g_o_-_4_2. xindy will recognize them and be able to sort them according to
  your specification which says that _H_i comes before all others and _h_e_r_e
  is exactly at the third position. So they will be sorted
  lexicographically, layer by layer, until it can decide which one is
  before or after the other. We have prepared a concrete example. Do you
  remember the example we gave when we spoke about indexing bible
  verses? This exactly matches the situation of such a self-defined
  alphabet which could look like the following definitions:



       (define-alphabet "bible-chapters"
           ("Genesis" "Exodus" "Leviticus" "Numbers" "Deuteronomy"
            ... ))
       (define-location-class "bible-verses"
           ("bible-chapters" :sep " " "arabic-numbers" :sep "," "arabic-numbers"))



  This description would match locations like _G_e_n_e_s_i_s _1_,_3, _E_x_o_d_u_s _7_,_8,
  etc.

  Now run LaTeX on eexx22..tteexx and view the results. It looks a little bit
  strange since xindy has automatically built ranges of successive
  locations. The first locations of the index entry _r_o_m_a_n actually
  denote the range _i_i until _i_v. _R_a_n_g_e_s consist of location references.
  To typeset them correctly you can specify



       (markup-range :sep "--")




  This indicates that location reference forming a range shall be
  separated by a hyphen. Running xindy and LaTeX again gives a better
  idea of how it should look like. Here is a part of the generated
  output.



         ...
        \item appendices\quad{}A-1, A-7, A-11, B-3--B-5, C-1, C-8, C-12,
                C-13, C-22, D-2, D-3, D-5, D-10
         ...





  33..22..  HHiieerraarrcchhiiccaall LLooccaattiioonn CCllaasssseess

  Somehow a lot of space is wasted when looking at the first index
  entry.  Modify the definition of the location class for appendices as
  follows and add the other commands as well:



       (define-location-class "appendices"
                              ("ALPHA" :sep "-" "arabic-numbers")
                              :hierdepth 2)
       (markup-locref-list            :sep "; " :depth 0 :class "appendices")
       (markup-locref-list :open "~~" :sep ", " :depth 1 :class "appendices")




  _N_o_t_e_: _S_i_n_c_e _t_h_e _t_i_l_d_e _c_h_a_r_a_c_t_e_r _s_e_r_v_e_s _a_s _o_u_r _q_u_o_t_i_n_g _c_h_a_r_a_c_t_e_r _i_t
  _m_u_s_t _b_e _q_u_o_t_e_d _i_t_s_e_l_f _i_n _t_h_e _a_b_o_v_e _e_x_a_m_p_l_e_. Run xindy and view the
  output stored in eexx22..iinndd. The output looks similar to the following:



         ...
        \item appendices\quad{}A~1, 7, 11; B~3--5; C~1, 8, 12, 13, 22;
               D~2, 3, 5, 10
         ...




  You can see that the location references of this class have been
  transformed into a hierarchical structure caused by the ::hhiieerrddeepptthh
  argument. Additionally we have specified markup for the layers of this
  class separately for the depths 0 and 1. The locations at depth 0 are
  separated by a `;' whereas the ones at depth 1 are separated by a `,'.

  Maybe you get an impression why we named xindy a _f_l_e_x_i_b_l_e system.


  33..33..  MMoorree aabboouutt LLeetttteerr GGrroouuppss

  More problems arise when using languages with different letter
  schemes. Hungarian is an example. In Hungarian indexes the words
  beginning with the letters _C_s_, _L_y_, _N_y and more are printed in a
  separate block. The words beginning with _L_y, for example, appear
  behind the words beginning with an _L. xindy allows to define this kind
  of letter groups as well. Add the following lines to the style file.



       (define-letter-group "ly" :after "l" :before "m")
       (define-letter-group "ny" :after "n" :before "o")

       (markup-letter-group :open-head "~n {\bf " :close-head "}"
                            :capitalize)




  The result looks like the following:




        ...
        {\bf Ly}
        \item lyuk\quad{}1
        \item lyukas\quad{}2

        \indexspace

        {\bf M}
        \item maga\quad{}1
        \item magyar\quad{}2

        \indexspace

        {\bf N}
        \item nagy\quad{}1
        \item nagyon\quad{}9
        \item ngy\quad{}4

        \indexspace

        {\bf Ny}
        \item nyelv\quad{}1
        \item nyolc\quad{}8
         ...




  The result describes what the purpose of the above commands is. It
  becomes prettier from step to step, doesn't it?

  You have now learned most of the features of xindy. Go playing around
  a little bit. For a detailed description of all commands and all their
  arguments and switches you should reference the manual that comes with
  this distribution.
  44..  RReeffeerreenncceess


  The following books and papers were referenced in this document.


  1. D. E. Knuth, _T_h_e _T_e_X_b_o_o_k, Addison-Wesley, 1984

  2. Leslie Lamport, LaTeX _A _D_o_c_u_m_e_n_t _P_r_e_p_a_r_a_t_i_o_n _S_y_s_t_e_m, Addison-
     Wesley, 1986

  3. Joachim Schrod, _A_n _I_n_t_e_r_n_a_t_i_o_n_a_l _V_e_r_s_i_o_n _o_f _M_a_k_e_I_n_d_e_x, Cahiers
     GUTenberg, 10, p81-90, 1991

  4. Pehong Chen and Michael A. Harrison, _A_u_t_o_m_a_t_i_n_g _I_n_d_e_x _P_r_e_p_a_r_a_t_i_o_n,
     TR-87/347, University of California Berkeley, 1987


  5. Roger Kehr, xindy, _E_i_n _F_l_e_x_i_b_l_e_s _I_n_d_e_x_i_e_r_u_n_g_s_s_y_s_t_e_m, Studienarbeit
     FB Informatik, TH-Darmstadt, November 1995.














































