{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyXindy","text":"PyXindy <p>Python port of xindy, the flexible index processor</p> Getting Started Explore the manual"},{"location":"home/","title":"PyXindy","text":"<p>Python reimplementation of xindy, the flexible index processor originally written in CLISP. PyXindy aims to be a drop-in replacement where the original xindy is difficult to install or integrate (for example with Tectonic or minimal TeX setups).</p> <p></p>"},{"location":"home/#background-and-history","title":"Background and history","text":"<ul> <li>makeindex: introduced in 1987 by Pehong Chen, bundled with TeX distributions through the late 1980s and 1990s as the default indexer for LaTeX. It remains widely available in TeX Live and MiKTeX.</li> <li>xindy: created in the mid-1990s (first public releases in 1996) by Joachim Schrod to handle multilingual indexing, flexible sort rules, and markup targets beyond TeX (SGML/HTML). Version 2.x has shipped with TeX Live since the early 2000s.</li> </ul> <p>Together they form a decades-old toolchain; PyXindy keeps the mature behavior while modernizing the implementation and packaging.</p>"},{"location":"home/#why-pyxindy-port","title":"Why PyXindy port","text":"<ol> <li>Easier installation: pure-Python stack, no CLISP dependency, plays nicely with <code>uv</code>, <code>pip</code>, and containerized CI.</li> <li>Better integration: Tectonic and other minimal TeX environments can use xindy-like features without installing a full TeX Live.</li> <li>Maintainability: Python codebase lowers the barrier for contributors and makes testing/CI straightforward.</li> <li>Extensibility: reuses the historical xindy modules/styles while making it simpler to experiment with new features or diagnostics.</li> </ol>"},{"location":"home/#usage","title":"Usage","text":"<pre><code>lualatex document.tex\nuv run xindy -M path/to/style.xdy -o document.ind document.raw\nlualatex document.tex\n</code></pre>"},{"location":"home/#quick-commands","title":"Quick commands","text":"<ul> <li>Generate an index from <code>.raw</code> with a <code>.xdy</code> style:</li> </ul> <p><code>bash   uv run xindy-py -M path/to/style.xdy -o output.ind path/to/index.raw</code></p> <ul> <li>Convert a TeX <code>.idx</code> file to <code>.raw</code>:</li> </ul> <p><code>bash   uv run texindy-py path/to/input.idx -o output.raw</code></p> <ul> <li>Use the makeindex-compatible interface:</li> </ul> <p><code>bash   uv run makeindex-py path/to/input.idx -o output.ind -t output.ilg -c</code></p>"},{"location":"home/#entry-points","title":"Entry points","text":"<ul> <li><code>xindy-py</code>: core processor; reads <code>.raw</code> plus <code>.xdy</code> style and renders the formatted index.</li> <li><code>texindy-py</code>: TeX converter; turns <code>.idx</code> into <code>.raw</code> suitable for xindy processing.</li> <li><code>makeindex-py</code>: makeindex-compatible wrapper layered on the xindy engine; supports <code>-c/-l/-o/-t</code> plus <code>-g/-q/-r/-p/-s</code> and multiple <code>.idx</code> inputs.</li> <li><code>makeglossaries-py</code>: glossaries helper; inspects LaTeX <code>.aux</code> to drive <code>makeindex-py</code>/xindy for glossary files.</li> </ul> <p>Historical xindy modules/styles (<code>vendor/xindy-2.1/modules</code>) are resolved automatically via <code>require</code>. The wrapper <code>makeindex-py</code> supports <code>-l/-c/-o/-t</code>, plus <code>-g/-q/-r/-p/-s</code> and multiple input files.</p>"},{"location":"home/#xindy-cli","title":"xindy CLI","text":"<pre><code>uv run xindy-py [-M style.xdy] [-o output.ind] [-L searchpath] [-C encoding] [-l logfile] [-t] input.raw\n</code></pre> <ul> <li><code>-M/--module/--style</code>: <code>.xdy</code> style to use (defaults to <code>&lt;raw&gt;.xdy</code>)</li> <li><code>-o/--output</code>: output target (<code>stdout</code> if omitted)</li> <li><code>-L/--searchpath</code>: extra search paths for <code>require</code> (merged with <code>XINDY_SEARCHPATH</code>)</li> <li><code>-C/--codepage</code>: output encoding (default: utf-8)</li> <li><code>-l/--log</code>: write a brief log file</li> <li><code>-t/--trace</code>: show Python tracebacks on errors</li> </ul>"},{"location":"home/#tex2xindy","title":"tex2xindy","text":"<pre><code>uv run texindy-py input.idx -o output.raw --input-encoding latin-1 --output-encoding utf-8\n</code></pre> <ul> <li>Handles hierarchies <code>!</code>, display <code>@</code>, encap <code>|</code>, basic TeX macros/escapes, crossrefs <code>see{target}</code> \u2192 <code>:xref</code>.</li> <li>Emits <code>:tkey</code> when the displayed form differs from the sort key.</li> </ul>"},{"location":"home/#makeindex4","title":"makeindex4","text":"<pre><code>uv run makeindex-py input.idx -o output.ind -t output.ilg [-c] [-l] [-g] [-q] [-r] [-p start] [-s style]\n</code></pre> <ul> <li><code>-c</code>: compress spaces in keys (makeindex behavior)</li> <li><code>-l</code>: ignore spaces for sorting (adds <code>sort-rule \" \" \"\"</code>)</li> <li><code>-g</code>: German ordering (loads <code>lang/german/din5007.xdy</code>)</li> <li><code>-q</code>: quiet mode (suppress stderr output)</li> <li><code>-r</code>: disable implicit page ranges</li> <li><code>-p</code>: set starting page number (numeric or <code>any|odd|even</code> using <code>.log</code>)</li> <li><code>-s</code>: load a <code>.xdy</code> style or a subset of <code>.ist</code> settings</li> <li><code>-i</code>: read from stdin; output defaults to stdout when <code>-o</code> is omitted</li> <li><code>--debug</code>: print tracebacks; otherwise errors are summarized and written to the <code>.ilg</code> log</li> <li>Generates a temporary style, detects attributes/crossrefs, loads <code>tex/makeidx4.xdy</code>.</li> </ul>"},{"location":"home/#examples","title":"Examples","text":"<ul> <li>Replay a historical fixture:</li> </ul> <p><code>bash   uv run xindy-py -M vendor/xindy-2.1/tests/ex1.xdy \\         -o /tmp/ex1.ind vendor/xindy-2.1/tests/ex1.raw</code></p> <ul> <li>Chain <code>.idx \u2192 .ind</code> in one command:</li> </ul> <p><code>bash   uv run makeindex-py vendor/xindy-2.1/tests/infII.idx -o /tmp/infII.ind</code></p>"},{"location":"home/about/","title":"About this Manual","text":""},{"location":"home/about/#python-port-of-xindy","title":"Python Port of Xindy","text":"<p>This manual is also a port/mirror of the original xindy manual. It was ported to MkDocs with minimal changes to the context and mostly with an automatic conversion. This is not the authoritative source of the xindy manual. For the authoritative source, please refer to the original xindy distribution.</p>"},{"location":"home/about/#introduction","title":"Introduction","text":"<p>We assume that the reader is already familiar with the task of an index processor and has basic experience in using a markup-based document preparation systems such as TeX/LaTeX [1, 2], the roff-family or SGML-based systems (e.g. its instance HTML).</p> <p>For a basic introduction into the handling and using of xindy refer to the tutorial that comes with this distribution.</p> <p>This document is structured as follows. The second part gives an overview on the index model that is used by our system and we define general concepts and terms. The third part contains a list of all index style commands, their syntax, and a description of their purpose. The reader should at least have read the first part of the manual to understand the basic terminology to be able to use the command reference. The fourth part describes how xindy can be invoked, what command line options are available and more. The fifth part describes the different processing phases the system runs through.</p>"},{"location":"home/features/","title":"Features","text":"<p>Here is a brief description of the most important features of xindy:</p>"},{"location":"home/features/#internationalization","title":"Internationalization","text":"<p>xindy can be configured to process indexes for many languages with different letter sets and different sorting rules. This captures also different orders (collating sequences such as Ly, Ny in Hungarian, or Ch, Ll in Spanish), even within one language. For example, many roman languages such as Italian, French, Portuguese or Spanish contain accented letters such as \u00c0, \u00c2, \u00f1;. Other languages from northern Europe have additional letters like \u00c4, \u00d8, \u00e6 or \u00df; which often can't be processed by many index processors, let alone sorting them correctly into an index.</p> <p>The xindy-system can be configured to process these alphabets with language-specific rules. One very basic example of such a rule would be (sort-rule \"\u00e4\" \"ae\") defining that a word containing the umlaut-a will be sorted as if it contained the letters ae instead. This is one of the two forms of how the umlaut-a is sorted into german indexes. With an appropriate set of rules one can express the complete rules of a specific language.</p>"},{"location":"home/features/#mark-up-normalization","title":"Mark-up Normalization","text":"<p>Formatters usually add mark-up to the raw index data. Often different encodings are used for the representation of an otherwise equal thing (e.g., in the context of TeX, umlaut-a may be represented as \u00e4, as ^^e4, or as \\\"a). xindy offers means to normalize these different encodings into one internal encoding, which is especially useful if the raw index stems from several different sources.</p>"},{"location":"home/features/#manage-non-standard-locations","title":"Manage Non-Standard Locations","text":"<p>Index entries refer to locations, commonly used locations are page numbers, section numbers, etc. xindy allows new types of locations to be defined. An example structure is represented by the following locations: Exodus 7:4, Psalm 46:1-8, and Genesis 1:31. The structure of bible verses can be described in xindy, allowing to correctly sort and process indexes for documents with such a strucure. Here the Psalms would be sorted before the Genesis verses in contrast to the usual order based on the lexicographic order of the chapter names.</p>"},{"location":"home/features/#module-support","title":"Module Support","text":"<p>All definitions concening the processing and tagging of an index are specified in a so-called index style. To support maximum reuse of building blocks xindy implements support for index style modules that allow end-users to profit from already existing styles. Just thing of modules as of LaTeX-packages that are used to load new features and definitions into the core system.</p>"},{"location":"home/features/#highly-configurable-mark-up","title":"Highly Configurable Mark-Up","text":"<p>Since an index processor is only one component in a document preparation system it ought to fit smoothly into the rest of the environment. Many document preparation systems use the concept of hierarchical environments that can be used to describe the mark-up of the text entities. Our approach is based on this concept which has proven to be expressive enough for almost any applications. Systems such as SGML (and its instance HTML), XML, GNU Info use environments a the underlying mark-up concept. The mark-up of an index can be defined for all of these and various other systems such as TeX/LaTeX, nroff, etc. in a very comfortable though extremly powerful way xindy comes with a context-based mark-up strategy that uses a form of event dispatching mechanism (sounds cool, eh? It is!)</p>"},{"location":"manual/","title":"xindy Manual","text":"<p>This is the migrated copy of the historic xindy 2.0 manual (Edition: February 1998) that previously lived as HTML under <code>vendor/xindy-2.1/Doc/</code>. The content is unchanged aside from light Markdown formatting so it is easier to browse alongside the rest of the docs. Images referenced by the manual now live in <code>docs/assets/</code>.</p> <p>Note: the Python port ships console scripts named <code>xindy-py</code>, <code>texindy-py</code>, and <code>makeindex-py</code> instead of the originals referenced in the upstream text. Command semantics are unchanged.</p>"},{"location":"manual/#python-port-entry-points","title":"Python port entry points","text":"<ul> <li><code>xindy-py</code>: run the index processor on <code>.raw</code> with a <code>.xdy</code> style.</li> <li><code>texindy-py</code>: convert LaTeX <code>.idx</code> to xindy <code>.raw</code>.</li> <li><code>makeindex-py</code>: makeindex-compatible wrapper on top of xindy.</li> <li><code>makeglossaries-py</code>: glossaries helper that routes to <code>makeindex-py</code>/xindy based on <code>.aux</code>.</li> </ul>"},{"location":"manual/command-reference/","title":"Command List","text":"<p>Here is the complete list of xindy's commands that may be used in the index style. The symbol <code>name</code> always refers to a string. We separate the commands into the processing and markup commands. The commands are listed in alphabetical order.</p> <p>The parenthesis <code>[`' and</code>]<code>' denote optional parts of the syntax and ``{</code>' and <code>`}</code>' denote the grouping of elements. A vertical bar indicates alternatives. However, the enclosing round braces are part of the syntax and must be supplied.</p>"},{"location":"manual/command-reference/#processing-commands","title":"Processing Commands","text":"<p>Here follows the list of processing commands.</p>"},{"location":"manual/command-reference/#define-alphabet","title":"define-alphabet","text":"<pre><code>(define-alphabet name string-list)\n</code></pre> <p>Defines <code>name</code> to be the alphabet consisting of all elements of the <code>string-list</code>. Examples:</p> <pre><code>  (define-alphabet \"example-alphabet\" (\"An\" \"Example\" \"Alphabet\"))\n</code></pre> <p>defines an alphabet consisting of exactly three symbols. For the successor relationship holds: <code>succ(\"An\")=\"Example\"</code> and <code>succ(\"Example\")=\"Alphabet\"</code>. The built-in alphabet <code>digits</code> is defined as follows:</p> <pre><code>  (define-alphabet \"digits\"\n                   (\"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\"))\n</code></pre>"},{"location":"manual/command-reference/#define-attributes","title":"define-attributes","text":"<pre><code>(define-attributes attribute-list)\n</code></pre> <p>Defines all attributes the raw index may contain. Parameter <code>attribute-list</code> is a list of list of strings. The nesting level must not be more than 2. So <code>(..(..)..)</code> is allowed, whereas <code>(..(..(..)..)..)</code> is not.</p> <p>The list has two kinds of elements: strings and list of strings. A single string is treated as if it were a single element list. So the lists <code>(\"definition\")</code> and <code>( (\"definition\") )</code> are equivalent. All elements forming a list are a so-called attribute group. The members of a group are written to the output file before any member of the following groups are written.</p> <p>Examples of valid attributes lists are:</p> <p><code>(\"definition\" \"usage\")</code> defines two attribute groups. The first one contains all references with the attribute <code>definition</code> and the second one all with the attribute <code>usage</code>.</p> <p><code>((\"definition\" \"important\") \"usage\")</code> defines two attribute groups. The first one contains all references with the attributes <code>definition</code> or <code>important</code> and the second one all with the attribute <code>usage</code>. In the attribute group <code>(\"definition\" \"important\")</code> the attribute <code>definition</code> overrides <code>important</code>.</p>"},{"location":"manual/command-reference/#define-crossref-class","title":"define-crossref-class","text":"<pre><code>(define-crossref-class name [:unverified])\n</code></pre> <p>Defines <code>name</code> to be a class of cross references. We distinguish two types of cross reference classes. Verified cross reference classes can be checked for dangling references. If for instance a cross reference points to the non-existent keyword <code>foo' a warning is issued and the user is advised to correct the invalid cross reference. This is the default. If for some reasons this mechanism must be deactivated the switch</code>:unverified` can be used to suppress this behaviour.</p>"},{"location":"manual/command-reference/#define-letter-group","title":"define-letter-group","text":"<pre><code>(define-letter-group name [:before lgname] [:after lgname]\n                          [:prefixes list-of-prefixes])\n\n(define-letter-groups list-of-letter-groups)\n</code></pre> <p>This command defines a letter group with name <code>name</code>, which must be a string value, grouping all index entries that have a sort key beginning with the prefix <code>name</code>. The command</p> <pre><code>  (define-letter-group \"a\")\n</code></pre> <p>is equivalent to the command</p> <pre><code>  (define-letter-group \"a\" :prefixes (\"a\"))\n</code></pre> <p>Using the latter form one can associate more than one prefix with a given letter group. Also further prefixes can be added to an already existing letter group by simply defining the same letter group again. This results not in a redefinition but in adding more prefixes to the currently defined prefixes.</p> <p>Example:</p> <pre><code>  (define-letter-group \"a\")\n</code></pre> <p>defines a letter group containing all index entries beginning with the string <code>\"a\"</code>.</p> <pre><code>  (define-letter-group \"c\" :after \"a\")\n</code></pre> <p>defines a letter group containing all index entries beginning with the string <code>\"c\"</code>. The letter group appears behind the letter group \"a\"</p> <pre><code>  (define-letter-group \"b\" :after \"a\" :before \"c\")\n</code></pre> <p>inserts letter group \"b\" between letter group \"a\" and \"c\". This allows incremental definition of letter groups by extending already defined ones.</p> <p>The arguments <code>:after</code> and <code>:before</code> define a partial order on the letter groups. xindy tries to convert this partial order into a total one. If this is impossible due to circular definitions, an error is reported. If more than one possible total ordering can result, it is left open which one is used, so one should always define a complete total order.</p>"},{"location":"manual/command-reference/#define-letter-groups","title":"define-letter-groups","text":"<p>The command <code>define-letter-groups</code> (with an <code>s' at the end) is simply an abbreviation for a sequence of</code>define-letter-group` definitions where the elements are ordered in the ordering given by the list. Example:</p> <pre><code>  (define-letter-groups (\"a\" \"b\" \"c\")\n</code></pre> <p>equals the definitions</p> <pre><code>  (define-letter-group \"a\")\n  (define-letter-group \"b\" :after \"a\")\n  (define-letter-group \"c\" :after \"b\")\n</code></pre> <p>See also commands <code>markup-letter-group-list</code> and <code>markup-letter-group</code> for further information.</p>"},{"location":"manual/command-reference/#define-location-class","title":"define-location-class","text":"<pre><code>(define-location-class name layer-list\n                       [:min-range-length num]\n                       [:hierdepth depth]\n                       [:var])\n</code></pre> <p>Defines <code>name</code> to be a location class consisting of the given list of layers. A list of layers consists of names of basetypes and/or strings representing separators. Separators must follow the keyword argument <code>:sep</code>. If the keyword <code>:min-range-length</code> is specified we define the minimum range length to be used when building ranges. The argument <code>num</code> must be a positive integer number or the keyword <code>none</code> in which case the building of ranges is disallowed. If the switch <code>:var</code> is specified the declared class is of type variable, i.e. it is a var-location-class. Since building of ranges is currently only allowed for standard classes <code>:var</code> and <code>:min-range-length</code> must not be used together. The keyword argument <code>:hierdepth</code> can be used to declare that the location references have to be tagged in a hierarchical form. Its argument <code>depth</code> must be an integer number indicating the number of layers the hierarchy does contain. See command <code>markup-locref-list</code> for more information. Examples:</p> <pre><code>  (define-location-class \"page-numbers\" (\"arabic-numbers\")\n                         :minimum-range-length 3)\n</code></pre> <p>Defines the location class <code>page-numbers</code> consisting of one layer which is the alphabet <code>arabic-numbers</code>. Since the minimum range length is set to 3 the location references 2, 3 and 4 don't form a range because the range length is only 2. But the references 6, 7, 8, and 9 are enough to form a range. Some example instances of this class are <code>0</code>, <code>1</code>, ... <code>2313</code>, etc.</p> <pre><code>  (define-location-class \"sections\" :var\n     (\"arabic-numbers\" :sep \".\"\n      \"arabic-numbers\" :sep \".\"\n      \"arabic-numbers\"))\n</code></pre> <p>defines a variable location class. Valid instances are <code>1</code>, <code>1.1</code>, <code>1.2</code>, <code>2</code>, <code>2.4.5</code>, but none of <code>2-3</code> (wrong separator), <code>1.2.3.4</code> (more than 3 layers), <code>2.3.iv</code> (roman number instead of arabic one).</p>"},{"location":"manual/command-reference/#define-location-class-order","title":"define-location-class-order","text":"<pre><code>(define-location-class-order list)\n</code></pre> <p>Defines the order in which the location classes are written to the output file. The parameter <code>list</code> is a list of names of location classes. Examples:</p> <pre><code>  (define-location-class-order\n      (\"page-numbers\" \"sections\" \"xrefs\"))\n</code></pre> <p>tells the system that the page numbers should appear before the section numbers and that the cross references should appear at the end. If this command is omitted, the declaration order of the location classes in the index style is implicitly used as the output order. In the case that a location class does not appear in the list, the output may behave unexpectedly, so one should always enumerate all used location classes when using this command.</p>"},{"location":"manual/command-reference/#define-rule-set","title":"define-rule-set","text":"<pre><code>(define-rule-set name\n        [ :inherit-from (\"rule-set\" \"rule-set-2\") ]\n        :rules (&lt;rule&gt;...) )\n</code></pre> <p>A complete specification of a multi-phase sorting process for a language requires that some rules have to appear in several subsequent sorting phases. Rule sets can be used to define a set of rules that can be instantiated in an arbitrary sorting phase. Basically, they offer means to separate the definition of sorting rules from their instantiation, hence, acting as a wrapper for calls to <code>sort-rule</code>. They do not add new functionality that is not already present with <code>sort-rule</code>.</p> <p>A rule can be of the form:</p> <pre><code>  &lt;rule&gt; ::= (\"pattern\" \"replacement\"\n              [:string|:bregexp|:egegexp] [:again])\n</code></pre> <p>The following incomplete example defines a new rule set of name <code>isolatin1-tolower</code> that inherits definitions from rule set <code>latin-tolower</code>, overriding or adding the sort rules in the list of <code>:rules</code>.</p> <pre><code>   (define-rule-set \"isolatin1-tolower\"\n\n     :inherit-from (\"latin-tolower\")\n\n     :rules ((\"\u00c0\" \"\u00e0\" :string :again)\n             (\"\u00c1\" \"\u00e1\" :string :again)\n             (\"\u00c2\" \"\u00e2\" :string :again)\n             (\"\u00c3\" \"\u00e3\" :string :again)\n             (\"\u00c4\" \"\u00e4\" :string :again)\n             (\"\u00c5\" \"\u00e5\" :string :again)\n             (\"\u00c6\" \"\u00e6\" :string :again)\n          ...\n            )\n   ...)\n</code></pre> <p>Rule sets can be instantiated with the command <code>use-rule-set</code>. For further descriptions on the sorting model refer to the command <code>sort-rule</code>.</p>"},{"location":"manual/command-reference/#define-sort-rule-orientations","title":"define-sort-rule-orientations","text":"<pre><code>(define-sort-rule-orientations (orientations...))\n</code></pre> <p>Defines the order for the different sorting phases. The currently implemented orientations are <code>forward</code> and <code>backward</code>. This command must precede all <code>sort-rule</code> commands in an index style. It defines the orientations and implicitly sets the maximum number of sorting phases performed.</p> <p>For further descriptions on the sorting model refer to the command <code>sort-rule</code>.</p>"},{"location":"manual/command-reference/#merge-rule","title":"merge-rule","text":"<pre><code>(merge-rule pattern replacement [:again]\n                                [:bregexp | :eregexp | :string])\n</code></pre> <p>Defines a keyword mapping rule that can be used to generate the merge key from the main key of an index entry. This mapping is necessary to map all keywords that are differently written but belong to the same keyword to the same canonical keyword.</p> <p>The parameter <code>pattern</code> can be a POSIX-compliant regular expression or an ordinary string. The implementation uses the GNU Rx regular expression library which implements the POSIX regular expressions. Regular expressions (REs) can be specified as basic regular expressions (BREs) or extended regular expressions (EREs). You can use the switch <code>:bregexp</code> to force the interpretation of the pattern as a BRE, or <code>:eregexp</code> to interpret it as an ERE. If you want xindy to interpret the pattern literally, use the switch <code>:string</code>. If none of these switches is selected, xindy uses an auto-detection mechanism to decide, if the pattern is a regular expression or not. If it recognizes the pattern as a RE, it interprets it as an ERE by default.</p> <p>The parameter <code>replacement</code> must be a string possibly containing the special characters <code>&amp;</code> (substitutes for the complete match) and <code>\\1</code> ,..., <code>\\9</code></p> <p>(substituting for the n-th submatch. Examples:</p> <pre><code>  (merge-rule \"A\" \"a\")\n</code></pre> <p>replaces each occurrence of the uppercase letter <code>`A</code>' with its lowercase counterpart.</p> <pre><code>  (merge-rule \"\\~\"([AEOUaeou])\" \"\\1\")\n</code></pre> <p>transforms the TeX umlaut-letters into their stripped counterparts, such that <code></code>\\\"A<code>' is treated as an ``A</code>' afterwards.</p> <p>The following sequences have a special meaning:</p> <p><code></code>~n` ' : End of line symbol (linefeed).</p> <p><code></code>~b` ' : The ISO-Latin character with the lowest ordinal number.</p> <p><code></code>~e` ' : The ISO-Latin character with the highest ordinal number.</p> <p><code></code>~~` ' : The tilde character.</p> <p><code></code>~\"` ' : The double quote character.</p> <p>Tilde characters and double quotes have to be quoted themselves with a tilde character. The special characters <code></code>~b<code>' and</code> <code>~e</code> ' allow the definition of arbitrary sorting orders by rules. In connection with an additional character every position in the alphabet can be described. E.g. <code></code>m~e<code>' is lexicographically placed between ``m</code>' and <code>`n</code>'.</p> <p>Due to efficiency, rules that just exchange characters or substitute constant character sequences are not treated as regular expressions. Therefore, instead of using the rule</p> <pre><code>  (merge-rule \"[A-Z]\" \"&amp;ampx\")\n</code></pre> <p>it is more efficient (though less comfortable) to use</p> <pre><code>  (merge-rule \"A\" \"Ax\")\n  (merge-rule \"B\" \"Bx\")\n  ...\n  (merge-rule \"Z\" \"Zx\")\n</code></pre> <p>Usually rules are applied in order of their definition. Rules with a special prefix precede those that begin with a class of characters, so that the search pattern <code>alpha`' is checked before</code>._<code>', but ``auto</code>' and <code>`a._</code>' are checked in order of their definition.</p> <p>The first rule from a style file that matches the input is applied and the process restarts behind the substituted text. If no rule could be applied, the actual character is copied from the input and the process continues with the next character.</p> <p>Sometimes it is necessary to apply rules anew to the result of a transformation. By specifying the keyword argument <code>:again</code> in the merge rule the rule is marked as mutable, which means that after using this rule the transformation process shall restart at the same place. E.g. the rule</p> <pre><code>  (merge-rule \"\\$(.*)\\$\" \"\\1\" :again)\n</code></pre> <p>deletes all surrounding <code></code>$` ' symbols from the input.</p> <p>See also command <code>sort-rule</code>.</p>"},{"location":"manual/command-reference/#merge-to","title":"merge-to","text":"<pre><code>(merge-to attr-from attr-to [:drop])\n</code></pre> <p>A merge rule says that the attribute <code>attr-from</code> can be used to build ranges in <code>attr-to</code>. Both attributes must name valid attribute names. The switch <code>:drop</code> indicates, that the original location reference with attribute <code>attr-from</code> has to be dropped (removed), if a successful range was built with location references in attribute <code>attr-to</code>. A detailed description is given in the section about processing phases.</p>"},{"location":"manual/command-reference/#require","title":"require","text":"<pre><code>(require filename)\n</code></pre> <p>This command allows to load more index style modules. The module is searched in the directories defined in the search path. The file is read in and processing of the current file continues. The argument <code>filename</code> must be a string. This allows to decompose the index style into several modules that can be included into the topmost index style file. Example:</p> <pre><code>  (require \"french/alphabet.xdy\")\n  (require \"french/sort-rules.xdy\")\n  (require \"tex/locations.xdy\")\n  (require \"tex/markup.xdy\")\n</code></pre> <p>Submodules can load other submodules as well. If a file is required that was already loaded, the <code>require</code> command is simply ignored and processing continues without including this file twice. See also command <code>searchpath</code>.</p>"},{"location":"manual/command-reference/#searchpath","title":"searchpath","text":"<pre><code>(searchpath {path-string | path-list})\n</code></pre> <p>This command adds the given paths to the list of paths, xindy searches for index style files. The argument <code>path-string</code> must be a colon-separated string of directory names. If this path ends with a colon the default search path is added to the end of the path list. Example:</p> <pre><code>  (searchpath \".:/usr/local/lib/xindy:/usr/local/lib/xindy/english:\")\n</code></pre> <p>adds the specified directories to the search path. Since the last path ends with a colon, the built-in search path is added at the end. Specifying</p> <pre><code>  (searchpath (\".\"\n               \"/usr/local/lib/xindy\"\n               \"/usr/local/lib/xindy/english\"\n               :default))\n</code></pre> <p>yields exactly the same result as the example above. Here <code>path-list</code> must be a list of strings and/or the keyword(s) <code>:default</code> and <code>:last</code>. The keyword <code>:default</code> signifies that the default pathnames are to be inserted at the specified position in the list. The keyword <code>:last</code> allows to insert the currently active paths at the indicated position. Since this allows to insert the built-in paths at any position and incrementally adding new paths to the search path, this version of the command ist more flexible than the first version.</p>"},{"location":"manual/command-reference/#sort-rule","title":"sort-rule","text":"<pre><code>(sort-rule pattern replacement [:run level] [:again])\n</code></pre> <p>Defines a keyword mapping rule that can be used to generate the sort key of an index entry from the merge key. This key is used to sort the index entries lexicographically after they have been merged using the merge key.</p> <p>The argument <code>:run</code> indicates that this rule is only in effect a the specified level (default is level 0). For a detailed discussion on the definition of sort rules for different layers refer to the documentation about the new sorting scheme (<code>new-sort-rules</code>) that comes with this distribution.</p> <p>See command <code>merge-rule</code> for more information about keyword rules.</p>"},{"location":"manual/command-reference/#use-rule-set","title":"use-rule-set","text":"<pre><code>(use-rule-set [:run phase]\n              [:rule-set ( &lt;rule-set&gt;... ))\n</code></pre> <p>This command instantiates the gives rule sets to be in effect at sorting phase <code>phase</code>. The order of the rule sets given with argument <code>:rule-set</code> is significant. Rule set entries of rule set appearing at the beginning of the list override entries in rule sets at the end of the list.</p> <p>The following example declares that in phase 0 the rule sets <code>din5007</code> and <code>isolatin1-tolower</code> should be active, whereas in phase 2 the other rule sets have to be applied.</p> <pre><code>  (use-rule-set :run 0\n                :rule-set (\"din5007\" \"isolatin1-tolower\"))\n\n  (use-rule-set :run 1\n                :rule-set (\"resolve-umlauts\"\n                           \"resolve-sharp-s\"\n                           \"isolatin1-tolower\"\n                           ))\n</code></pre> <p>For a discussion on rule sets refer to command <code>define-rule-set</code>.</p>"},{"location":"manual/command-reference/#markup-commands","title":"Markup Commands","text":"<p>The following commands can be used to define the markup of the index. They don't have any influence on the indexing process. Since the markup scheme is characterized by the concept of environments, the syntax and naming scheme of all commands follows a simple structure.</p> <p>The commands can be separated into environment and list-environment commands. All commands of the first group support the keyword arguments <code>:open</code> and <code>:close</code>, whereas the second group additionally supports the keyword argument <code>:sep</code>. If one of these keyword arguments is missing, the default markup tag is always the empty tag. The <code>:open</code> tag is always printed before the object itself and the <code>:close</code> tag is always printed after the object has been printed. If a list is printed the <code>:sep</code>tag is printed between two elements of the list but not before the first element, or after the last one. All commands dealing with a list have the suffix <code>`-list</code>' as part of their command name.</p> <p>Since the number of commands and the heavy usage of default and specialized tags makes the markup somehow complex (but very powerful) we have added a mechanism to trace the markup tags xindy omits during its markup phase with the command <code>markup-trace</code>.</p> <p>Here follows the list of markup commands in alphabetical order with some of the commands grouped together.</p>"},{"location":"manual/command-reference/#markup-attribute-group-list","title":"markup-attribute-group-list","text":"<pre><code>(markup-attribute-group-list [:open string] [:close string]\n                             [:sep string])\n</code></pre> <p>Location class groups consist of lists of attribute groups. The markup of this list can be defined with the command <code>markup-attribute-group-list</code>.</p>"},{"location":"manual/command-reference/#markup-attribute-group","title":"markup-attribute-group","text":"<pre><code>(markup-attribute-group      [:open string] [:close string]\n                             [:group group-num])\n</code></pre> <p>To allow different markup for different attribute groups the command <code>markup-attribute-group</code> can be specialized on the group number with the keyword argument <code>:group</code> which must be an integer number. Given the groups <code>(\"definition\" \"theorem\")</code> and <code>(\"default\")</code> with group numbers 0 and 1, then</p> <pre><code>  (markup-attribute-group :open \"&lt;group0&gt;\" :close \"&lt;/group0&gt;\"\n                          :group 0)\n\n  (markup-attribute-group :open \"&lt;group1&gt;\" :close \"&lt;/group1&gt;\"\n                          :group 1)\n</code></pre> <p>can assign different markup for both groups in a SGML-based language.</p>"},{"location":"manual/command-reference/#markup-crossref-list","title":"markup-crossref-list","text":"<pre><code>(markup-crossref-list       [:open string] [:close string]\n                            [:sep string]\n                            [:class crossref-class])\n</code></pre> <p>A crossref class group contains cross references of the same class. The separator between the classes is defined with the <code>(markup-locclass-list :sep)</code>-parameter. A list of cross references can be tagged with the command <code>markup-crossref-list</code> that specializes on the <code>:class</code> argument.</p>"},{"location":"manual/command-reference/#markup-crossref-layer-list","title":"markup-crossref-layer-list","text":"<pre><code>(markup-crossref-layer-list [:open string] [:close string]\n                            [:sep string]\n                            [:class crossref-class])\n</code></pre> <p>Each cross reference is determined by a list of layers indicating the target of the cross reference. To define suitable markup for such a list the command <code>markup-crossref-layer-list</code> can be used.</p>"},{"location":"manual/command-reference/#markup-crossref-layer","title":"markup-crossref-layer","text":"<pre><code>(markup-crossref-layer      [:open string] [:close string]\n                            [:class crossref-class])\n</code></pre> <p>Each layer of a cross reference can be assigned two tags that specialize on the class of the reference, like all other commands.</p> <p>A suitable markup for a cross reference class <code>see</code> within LaTeX2e could look like that:</p> <pre><code>  (markup-crossref-list :class \"see\" :open \"\\emph{see} \"\n                                     :sep  \"; \")\n  (markup-crossref-layer-list :class \"see\" :sep \",\")\n  (markup-crossref-layer :class \"see\"\n                                     :open \"\\textbf{\" :close \"}\")\n</code></pre> <p>An example output could look like</p> <p>... see house; garden,winter; greenhouse</p>"},{"location":"manual/command-reference/#markup-index","title":"markup-index","text":"<pre><code>(markup-index [:open string] [:close string]\n              [ :flat | :tree | :hierdepth depth ])\n</code></pre> <p>Defines the markup tags that enclose the whole index via the <code>:open</code> and <code>:close</code> parameters. Examples:</p> <pre><code>  (markup-index :open  \"Here comes the index~n\"\n                :close \"That's all folks!~n\")\n</code></pre> <p>defines that the <code>:open</code> string is printed before the rest of the index and the <code>:close</code> string appears after the index is printed.</p> <p>Additionally one can specify the form of the generated index. It is possible to produce flat indexes by specifying the switch <code>:flat</code>, to generate a tree with the <code>:tree</code> switch or any kind of mixture between both by specifying the depth up to which trees shall be built with the parameter <code>:hierdepth</code>. Its argument <code>depth</code> is the number of layers that can be formed into a tree. Therefore <code>:flat</code> is an abbrevation of <code>:hierdepth 0</code> and <code>:tree</code> is an abbrevation of <code>:hierdepth max-depth</code>, with <code>max-depth</code> being the maximum number of layers a keyword has. An example: the keywords</p> <pre><code>  (\"tree\" \"binary\" \"AVL\")\n  (\"tree\" \"binary\" \"natural\")\n</code></pre> <p>can be transformed in the following ways:</p> <p>A flat index (<code>:flat</code> or <code>:hierdepth 0</code>)</p> <pre><code>  tree binary AVL\n  tree binary natural\n</code></pre> <p>with <code>:hierdepth 1</code></p> <pre><code>  tree\n     binary  AVL\n     binary  natural\n</code></pre> <p>and a tree (<code>:tree</code> or <code>:hierdepth</code> &gt; 1)</p> <pre><code>  tree\n     binary\n        AVL\n        natural\n</code></pre> <p>Most often one will create tree-like indexes or ones that are flat.</p>"},{"location":"manual/command-reference/#markup-indexentry-list","title":"markup-indexentry-list","text":"<pre><code>(markup-indexentry-list [:open string] [:close string]\n                        [:sep string]  [:depth integer])\n\n(markup-indexentry      [:open string] [:close string]\n                        [:depth integer])\n</code></pre> <p>Letter groups consists of a list of index entries. The command <code>markup-indexentry-list</code> defines the markup of these lists. The markup can be specialized on the depth if the index is hierarchically organized. The command</p> <pre><code>  (markup-indexentry-list :open  \"\\begin{IdxentList}\"\n                          :close \"\\end{IdxentList}\"\n                          :sep   \"~n\")\n</code></pre> <p>defines that the index entries of all layers are wrapped into the given markup tags. If additionally</p> <pre><code>  (markup-indexentry-list :open  \"\\begin{IdxentListII}\"\n                          :close \"\\end{IdxentListII}\"\n                          :sep   \"~n\"\n                          :depth 2)\n</code></pre> <p>is defined, all index entry lists of all layers (except layer 2) are tagged according to the first specification, and the index entry list within depth 2 are tagged according to the second rule.</p>"},{"location":"manual/command-reference/#markup-indexentry","title":"markup-indexentry","text":"<p>The command <code>markup-indexentry</code> defines the markup of an index entry at a given depth. Since index entries may also contain subentries and the markup for subentries may be different in different layers, the optional keyword argument <code>:depth</code> can be used to assign different markup for different layers. If depth is ommited the default markup for all possible depths is defined. The top-most index entries have depth 0.</p> <pre><code>  (markup-indexentry :open  \"\\begin{Indexentry}\"\n                     :close \"\\end{Indexentry}\")\n</code></pre> <p>defines that the index entries of all layers are wrapped into the given markup tags. If additionally</p> <pre><code>  (markup-indexentry :open  \"\\begin{IndexentryII}\"\n                     :close \"\\end{IndexentryII}\"\n                     :depth 2)\n</code></pre> <p>is defined, all index entries of all layers (except layer 2) are tagged according to the first specification, and the index entries with depth 2 are tagged according to the second rule.</p>"},{"location":"manual/command-reference/#markup-keyword-list","title":"markup-keyword-list","text":"<pre><code>(markup-keyword-list [:open string] [:close string]\n                     [:sep string] [:depth integer])\n\n(markup-keyword      [:open string] [:close string]\n                     [:depth integer])\n</code></pre> <p>The print key of an index entry consists of a list of strings. The markup of this list can be defined with the command <code>markup-keyword-list</code>. The keyword argument <code>:depth</code> may be specified to define the markup of the list at a particular depth.</p>"},{"location":"manual/command-reference/#markup-keyword","title":"markup-keyword","text":"<p>The keyword of an index entry consists of a list of strings. Each of these components is tagged with the strings defined with the command <code>markup-keyword</code>. Since we maybe need different markup for different layers, the optional keyword argument can be used to specialize this markup for some depth.</p>"},{"location":"manual/command-reference/#markup-letter-group-list","title":"markup-letter-group-list","text":"<pre><code>(markup-letter-group-list [:open string] [:close string]\n                          [:sep string])\n\n(markup-letter-group  [:open string] [:close string] [:group group-name]\n                      [:open-head string] [:close-head string]\n                      [:upcase | :downcase | :capitalize])\n</code></pre> <p>The first command defines the markup of the letter group with name <code>group-name</code>. Since the markup of letter groups often contains the name of the letter group as a part of it, the other keyword arguments allow an additional markup for this group name. If one of the parameters <code>:open-head</code> and <code>:close-head</code> is specified additional markup is added as can be described as follows:</p> <pre><code>  &lt;OPEN&gt;\n     IF (:open-head OR :close-head)\n       &lt;OPEN-HEAD&gt;\n         transformer-of(&lt;GROUP-NAME&gt;)\n       &lt;CLOSE-HEAD&gt;\n     FI\n     &lt;INDEXENTRIES...&gt;\n  &lt;CLOSE&gt;\n</code></pre> <p>Here, <code>transformer-of</code> is a function that possibly transforms the string representing the group name into another string. The transformers we currently support can be specified with the switches <code>:upcase</code>, <code>:downcase</code> and <code>:capitalize</code> which result in the corresponding string conversions. If none of them is specified no transformation is done at all.</p>"},{"location":"manual/command-reference/#markup-letter-group","title":"markup-letter-group","text":"<p>The command <code>markup-letter-group</code> defines the markup of the list of letter groups.</p>"},{"location":"manual/command-reference/#markup-locclass-list","title":"markup-locclass-list","text":"<pre><code>(markup-locclass-list [:open string] [:close string]\n                      [:sep string])\n</code></pre> <p>Each index entry contains a list of location class groups. This markup command can be used to define the markup of this list.</p>"},{"location":"manual/command-reference/#markup-locref","title":"markup-locref","text":"<pre><code>(markup-locref [:open string] [:close string]\n               [:class locref-class]\n               [:attr  attribute]\n               [:depth integer])\n</code></pre> <p>The markup tags of a location reference can be specialized on the three arguments <code>:class</code>, <code>:attr</code> and additionally, if sub-references are used, <code>:depth</code>. Most often one will only use a tag depending on the attribute. For example, all location references with the attribute <code>definition</code> should appear in a font series like bold, emphasizing the importance of this location reference; those with the attribute <code>default</code> in font shape italic. The markup in this case would not specialize on the depth or any particular class. A valid definition, suitable for a usage within HTML, could look like this.</p> <pre><code>  (markup-locref :open \"&lt;B&gt;\" :close \"&lt;/B&gt;\" :attr \"definition\")\n  (markup-locref :open \"&lt;I&gt;\" :close \"&lt;/I&gt;\" :attr \"default\")\n</code></pre>"},{"location":"manual/command-reference/#markup-locref-class","title":"markup-locref-class","text":"<pre><code>(markup-locref-class [:open string] [:close string]\n                     [:class locref-class])\n</code></pre> <p>All location references of a particular location reference class can be wrapped into the tags defined by this command. It specializes on the keyword argument <code>:class</code>.</p>"},{"location":"manual/command-reference/#markup-locref-layer","title":"markup-locref-layer","text":"<pre><code>(markup-locref-layer      [:open string] [:close string]\n                          [:depth integer] [:layer integer]\n                          [:class locref-class])\n</code></pre> <p>The command allows tagging elements of a layer list differently. The first element of this list can be specialized with <code>:layer 0</code>, the next element with <code>:layer 1</code>, etc.</p>"},{"location":"manual/command-reference/#markup-locref-layer-list","title":"markup-locref-layer-list","text":"<pre><code>(markup-locref-layer-list [:open string] [:close string]\n                          [:sep string]\n                          [:depth integer]\n                          [:class locref-class])\n</code></pre> <p>A location reference contains a list of location reference layers. The list command can markup this list. It specializes on the class of the location references and the depth (if sub-references are used).</p>"},{"location":"manual/command-reference/#markup-locref-list","title":"markup-locref-list","text":"<pre><code>(markup-locref-list [:open string] [:close string] [:sep string]\n                    [:depth integer] [:class locref-class])\n</code></pre> <p>An attribute group contains a list of location references and/or ranges. Additionally a layered location reference itself may contain sub-references that are stored as a list of location references. We specialize the markup for these lists on the location class they belong to with the keyword argument <code>:class</code>, and on <code>:depth</code> that specializes on the different subentry levels when using location references with sub-references.</p> <p>Given is a list of location references that have the class description</p> <pre><code>  (define-location-class \"Appendix\"\n                         (\"ALPHA\" :sep \"-\" \"arabic-numbers\")\n                         :hierdepth 2)\n</code></pre> <p>This location class has instances like <code>A-1</code>, <code>B-5</code>, etc. The keyword argument <code>:hierdepth 2</code> informs xindy to markup these location references in a hierarchical form. With the commands</p> <pre><code>  (markup-locref-list            :sep \"; \"\n                       :depth 0  :class \"Appendix\")\n  (markup-locref-list  :open \" \" :sep \",\"\n                       :depth 1  :class \"Appendix\")\n  (markup-locref-layer :open \"{\\bf \" :close \"}\" :layer 0\n                       :depth 0  :class \"Appendix\")\n</code></pre> <p>we obtain a markup sequence for some example data that could look like</p> <pre><code>  {\\bf A} 1,2,5; {\\bf B} 5,6,9; {\\bf D} 1,5,8; ...\n</code></pre>"},{"location":"manual/command-reference/#markup-range","title":"markup-range","text":"<pre><code>(markup-range [:open string] [:close string] [:sep string]\n              [:class locref-class]\n              [:length num] [:ignore-end])\n</code></pre> <p>A range consists of two location references. Markup can be specified with the <code>:open</code> and <code>:close</code> arguments and one separator given by the argument <code>:sep</code>.</p> <p>Since both location references are tagged with markup defined by the command <code>markup-locref</code> a specialization on attributes or depth is not necessary. Specialization is allowed on the class they belong to, because the separator between two location refences may be different for each location class. Argument <code>:length</code> can be used to define different markup for different lengths. In conjunction with <code>:length</code> is may be useful not to print the second location reference at all. For example, one wishes to markup ranges of length 1 in the form Xf. instead of X--Y. This can be accomplished with the switch <code>:ignore-end</code>.</p> <p>The markup tags for a range (X,Y) can be described as follows:</p> <pre><code>  &lt;OPEN&gt;\n    Markup of location reference X\n  &lt;SEP&gt;\n    IF (not :ignore-end)\n       Markup of location reference Y\n    FI\n  &lt;CLOSE&gt;\n</code></pre> <p>The following tags can be used to define a range of page numbers (given in a location class <code>page-numbers</code>) without considering the open and close parameters:</p> <pre><code>  (markup-range :sep \"-\" :class \"page-numbers\")\n</code></pre> <p>Location ranges then appear separated by a hyphen in a form like this:</p> <pre><code>   ..., 5-8, 19-23, ...\n</code></pre>"},{"location":"manual/command-reference/#markup-trace","title":"markup-trace","text":"<pre><code>(markup-trace [:on] [:open string] [:close string])\n</code></pre> <p>This command can be used to activate the tracing of all markup commands xindy executes. The switch <code>:on</code> activates the trace. If <code>:on</code> is omitted, the command line flag <code>-t</code> can be used as well. All tags which are emitted but not yet defined explicitly by the user are tagged with a symbolic notation indicating the commands that must be used to define this tag. The defaults for the keyword argument <code>:open</code> is <code>&lt;`' and for `:close` is</code>&gt;`'. The beginning of an example output could look like:</p> <pre><code>  &lt;INDEX:OPEN&gt;\n    &lt;LETTER-GROUP-LIST:OPEN&gt;\n      &lt;LETTER-GROUP:OPEN [\"a\"]&gt;\n        &lt;INDEXENTRY-LIST:OPEN [0]&gt;\n          &lt;INDEXENTRY:OPEN [0]&gt;\n            &lt;KEYWORD-LIST:OPEN [0]&gt;\n              &lt;KEYWORD:OPEN [0]&gt;\n   ...\n</code></pre> <p>We use a simple indentation scheme to make the structure of the tags visible. The symbolic tag <code>&lt;LETTER-GROUP:OPEN [\"a\"]&gt;</code> for example indicates that the tag that can be specified with the command</p> <pre><code>  (markup-letter-group :open \"XXX\" :group \"a\" ... )\n</code></pre> <p>is emitted at this point in the markup process. By incrementally adding markup commands to the index, more and more tags can be defined until the whole markup is defined. This general mechanism should allow everyone understand the markup process. The best is to start with a small index, define the complete markup and afterwards process the whole index. Additionally one can enclose the symbolic tags into an environment that is neutral to the document preparation system, such as a comment. For TeX this could be</p> <pre><code>  (markup-trace :open \"%%\" :close \"~n\")\n</code></pre> <p>or a definition in the TeX document like</p> <pre><code>  \\def\\ignore#1{}\n</code></pre> <p>combined with the command</p> <pre><code>  (markup-trace :open \"\\ignore{\" :close \"}\")\n</code></pre>"},{"location":"manual/command-reference/#raw-index-interface","title":"Raw Index Interface","text":"<p>This section can be skipped if the reader is not interested in adapting xindy to a new document preparation system.</p> <p>The raw index is the file that represents the index that is to be processed. Since many different document preparation systems may use different forms of index representations, their output must be transformed in a form readable by xindy. We also could have written an configurable parser performing this task, but usually a tool written with some text processing tools such as <code>perl</code>, <code>sed</code> or <code>awk</code> can achieve the same task as well. Therefore, adapting xindy to a completely different system can mostly be done by writing an appropriate raw index filter.</p> <p>The format of the raw index interface of xindy is defined as follows:</p>"},{"location":"manual/command-reference/#indexentry","title":"indexentry","text":"<pre><code>(indexentry { :key string-list [:print string-list]\n            | :tkey list-of-layers }\n            [:attr string]\n            { :locref string  [:open-range | :close-range]\n            | :xref string-list } )\n</code></pre> <p>The pseudo variable string is a sequence of characters surrounded by double quotes, e.g.</p> <pre><code>  \"Hi, it's me\"  \"one\"  \"a string with two \\\"double quotes\\\"\"\n</code></pre> <p>are three examples of valid strings. If you need to include a double quote as a literal character, you must quote it itself with a backslash as shown in the third example. A string list is simply a list of strings separated by whitespaces and surrounded by round braces. An example of a string list is</p> <pre><code>  (\"This\" \"is\" \"a\" \"list\" \"of\" \"strings\")\n</code></pre> <p>So far about the syntax. The semantics of the different elements are described here.</p> <p><code>:key</code> The argument string list defines the keyword of the index entry. It must be a list of strings, since the keyword may consist of different layers such as <code>(\"heap\" \"fibonacci\")</code>.</p> <p><code>:print</code> The optional print key defines the way the keyword has to be printed in the markup phase.</p> <p><code>:tkey</code> Another possibility to define the keys of an index entry is with the <code>:tkey</code> keyword argument. It can be used instead of the <code>:key</code> and <code>:print</code> arguments. Instead of specifying separately the key and the corresponding print key, we define the keyword by its layers. Each layer consist of a list of one or two strings. The first string will be interpreted as the main key, whereas the second one will become the print key. If the print key is ommited, the main key is taken instead. So the definition</p> <pre><code>  :tkey ((\"This\") (\"is\") (\"a\") (\"bang\" \"BANG !!!\"))\n</code></pre> <p>is equivalent to</p> <pre><code>  :key   (\"This\" \"is\" \"a\" \"bang\")\n  :print (\"This\" \"is\" \"a\" \"BANG !!!\")\n</code></pre> <p><code>:locref</code> The reference an index entry describes can be a location reference or a cross reference. The switch <code>:locref</code> describes a location reference. Its optional arguments are <code>:open-range</code> and <code>:close-range</code>. The string that must be supplied must somehow encode the location reference. It might look like the string <code>\"25\"</code> representing the page number 25, or <code>\"Appendix-I\"</code> representing the first appendix numbered in uppercase roman numerals.</p> <p><code>:open-range</code>,<code>:close-range</code> These are switches that do not take any arguments. They describe the beginning and ending of a range, starting or ending from the location reference that is given by the argument <code>:locref</code>. If they are supplied, the location reference may have influence on the way ranges are build.</p> <p><code>:xref</code> These arguments choose the second alternative. The argument string list of parameter <code>:xref</code> describes where the index entry should point to.</p> <p><code>:attr</code> This parameter may be used to tag a location reference with a certain attribute or it names the class of a cross reference. It may also used to associate different markup for different attributes in the markup phase. If this parameter is omitted or is the empty string, the indexentry is declared to have the attribute <code>default</code>.</p> <p>Some examples:</p> <pre><code>  (indexentry :key (\"airplane\") :locref \"25\" :attr \"default\")\n</code></pre> <p>defines an index entry with the key <code>airplane' indexed on page '25'. This index entry has the attribute</code>default`.</p> <pre><code>  (indexentry :key (\"house\") :xref (\"building\") :attr \"see\")\n</code></pre> <p>defines a cross reference with the key 'house' pointing to the term 'building'. This cross reference belongs to the cross reference class <code>see</code>.</p> <pre><code>  (indexentry :key (\"house\") :xref (\"building\") :open-range)\n</code></pre> <p>is an invalid specification, since <code>:open-range</code> mustn't be used together with cross references.</p>"},{"location":"manual/doc-readme/","title":"Legacy Doc README","text":"<p>This note comes from the original <code>vendor/xindy-2.1/Doc/README</code> (February 1997) and explains the contents of the legacy documentation tree. The GNU Info and plain text variants were auto-generated from SGML and can be clumsy; the TeX and HTML versions look better. The <code>tutorial</code> subdirectory contains the examples used in the tutorial.</p>"},{"location":"manual/how-the-index-processor-works/","title":"How the Index Processor Works","text":""},{"location":"manual/how-the-index-processor-works/#data-flow","title":"Data Flow","text":"<p>Usually document preparation systems produce some form data that describe the index entries and the locations they point to. This data is called the raw index since it consists of raw data which contains structured information about the entries of the index. The raw index is fed into the index processor and is processed according to a specification called the index style. This is a user-definable description how the index is to be processed, what sort rules for the keywords should be used, which kind of locations may appear, and finally, what tags should be emitted when writing the index into the output file. The result is sometimes fed back into the document preparation system, as it is in the case of TeX, or used otherwise. The following figure illustrates this embedding into the document preparation process.</p> <p></p> <p>The xindy system is oriented on book-like indexes in a form that is described later in detail. The format of the input data is fixed and a small tool that converts some system dependent raw index in a form suitable for xindy should not be a big hurdle. The user is normally not involved in the correct format suitable for xindy and some tools will make this work invisible to him.</p> <p>In contrast, the output of the xindy system is highly configurable and can produce a variety of different markups. Additionally, the way xindy processes the index data can be parametrized and controlled in many ways and gives the user a powerful framework for describing complex indexes. The user can tell xindy how it should produce an output according to his wishes or simply use some of the predefined styles that come with the distribution.</p>"},{"location":"manual/how-the-index-processor-works/#general-concepts-and-terms","title":"General Concepts and Terms","text":"<p>In the following sections we introduce some terms that are necessary to understand the way xindy works.</p> <p>The development of xindy started with the devlopment of a model of a book-like index. This rather vague term will now be fleshed out by giving a semi-formal description of the model. If the structure of an index conforms to this model it can be processed by xindy. We first present a diagram that describes the structure of a processed index. It is a hierarchical recursive data structure which we will describe now.</p> <p></p> <p>Boxed objects contain elements from the raw index such as the keywords or the location reference layers. We start from the root of the diagram and explain the different elements.</p>"},{"location":"manual/how-the-index-processor-works/#index","title":"Index","text":"<p>An index consists of a list of letter-groups.</p>"},{"location":"manual/how-the-index-processor-works/#letter-group","title":"letter-group","text":"<p>The letter groups serve as containers for indexentries. The letter groups are intended to group all index entries sharing a common keyword prefix, allowing the assignment of a specific markup for each group. For example, indexes are often organized in a way that new index entries beginning with a new letter are separated by a specific markup. The following example illustrates this style.</p> <pre><code>B\nbread      25, 27\nbutter     26\nM\nmarmalade  19\nmilk       21\n</code></pre> <p>Here we have two letter groups for the letters <code>B' and</code>M' because the keywords <code>bread' and</code>butter' share the same prefix <code>b' and</code>marmalade' and <code>milk' share the prefix</code>m'. xindy can be advised to define arbitrary letter groups with a particular markup for each of them. See command <code>define-letter-group</code> for further details.</p>"},{"location":"manual/how-the-index-processor-works/#indexentry","title":"indexentry","text":"<p>An index entry consists of three components: the keyword and optionally the list of location-class-groups and the sub-indexentries. An example:</p> <pre><code>bread   25-30\n    brown   26\n    white   27\n</code></pre> <p>This index entry consists of the keyword <code>bread', the location class list</code>25-30' and the sub-entries <code>brown 26' and</code>white 27'. The sub-entries themselves are complete index entries as well, forming a recursive data structure.</p>"},{"location":"manual/how-the-index-processor-works/#keyword","title":"keyword","text":"<p>The keyword is the identifier of an index entry. It consists of a list of strings being the key if the index entry. In our model the keyword constists of a list of strings, since indexes are often organized hierarchically with different layers. In the example</p> <pre><code>    bread         25-30\n    bread, brown     26\n    bread, white     27\n</code></pre> <p>we have keywords <code>bread',</code>bread, brown' and `bread, white'.</p> <p>A keyword is actually separated into four different keys. The main-key is the key that is specified from the author who indexes a document. The merge-key is derived from the main key with the so-called merge mapping. This mapping is accomplished with a set of rewrite rules. The sort-key is derived from the merge key with another set of rewrite rules called the sort mapping. The print-key can be specified by the user explicitely or, if it is ommited, equals the main key. The rewrite rules consist of string substitutions that also include regular expression features.</p> <p>The following figure describes this:</p> <p></p> <p>The merge-key is necessary to define the equality of index entry keys. See command <code>merge-rule</code> for further details about defining the merge mapping.</p> <p>The sort-key is necessary to define a total order on the keywords. Since we need a scheme that is independent from any specific character set such as ASCII or ISO-Latin, we must be able to define completely new alphabets. The index entries are then sorted according to the ISO-Latin alphabet. See the command <code>sort-rule</code> for an explanation how these mapping can be specified.</p> <p>The print-key is used for the final markup and contains the string that appears in the generated markup.</p>"},{"location":"manual/how-the-index-processor-works/#location-class-group","title":"location-class-group","text":"<p>There exist two kinds of location class groups namely location-reference-groups and cross-reference-groups.</p>"},{"location":"manual/how-the-index-processor-works/#location-reference-group","title":"location-reference-group","text":"<p>consists of a list of attribute-groups.</p>"},{"location":"manual/how-the-index-processor-works/#attribute-groups","title":"attribute-groups","text":"<p>Each location-reference-group consists of a list of attribute-groups. Attribute groups are defined by a set of attributes. In the markup phase, all location references are sorted according to the group number their attributes belong to. Additionally all location references of a particular attribute group appear together in the index.</p> <p>See command <code>define-attribute-groups</code> for further information about the handling of attribute-groups.</p> <p>An attribute group consists of a list of location-references and/or ranges.</p>"},{"location":"manual/how-the-index-processor-works/#location-reference-class-location-reference-location","title":"location-reference-class, location-reference, location","text":"<p>Each index entry of an index references at least one location in the document. A location is a logical or physical part of a document, such as a single page, a section or subsection, etc. The symbolic name of a location is called a location-reference. The location reference is always represented as a string (a sequence of characters). Each location reference is associated a special tag called attribute. The following examples may give you an idea how location references could look like.</p> <ul> <li><code>\"25\"</code> represents a page number.</li> <li><code>\"Chapter-3\"</code> represents the third chapter of a document.</li> <li><code>\"A-I\"</code> represents the first page, written in uppercase roman numerals of the appendix `A', separated by a hyphen.</li> <li><code>\"2.3.4\"</code> represents the sub-sub-section 2.3.4 of a document.</li> </ul> <p>As we can see, the location references are often composed hierarchically of smaller entities, such as numbers or names. All location references that belong to the same class form a location-class. A location class is composed of alphabets and separators. See command <code>define-location-class</code> for a description how classes can be defined.</p>"},{"location":"manual/how-the-index-processor-works/#alphabet-separator","title":"alphabet, separator","text":"<p>As we have seen in the previous section, location classes consist of alphabets and separators. xindy has the following built-in set of basic alphabets:</p> <p><code>arabic-numbers</code> contains all non-negative numbers beginning with zero: 0, 1, 2, ....</p> <p><code>roman-numerals-uppercase</code> the roman numerals I, II, III, (IIII/IV), V, ... It recognizes the old and new roman numeral system.</p> <p><code>roman-numerals-lowercase</code> the same for the lowercase roman numerals.</p> <p><code>ALPHA</code> the US-ASCII alphabet (uppercase letters).</p> <p><code>alpha</code> the US-ASCII alphabet (lowercase letters).</p> <p><code>digits</code> the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9 in this order.</p> <p>The user is free to define new alphabets as he wishes. See the commands <code>define-alphabet</code> and <code>define-enumeration</code> for further details.</p> <p>A complete location class can be defined by composing alphabets and separators. The location class of the example <code>\"A-I\"</code> can be defined as follows</p> <pre><code>  (define-location-class \"appendix\"\n                         (ALPHA \"-\" roman-numerals-uppercase))\n</code></pre> <p>This is a list that completely describes all possible instances of this location class. Other valid members are <code>A-II</code>, <code>B-VI</code>, etc. Location classes are defined with the command <code>define-location-class</code>.</p> <p>xindy reads the incoming strings representing location references and tries to match them against a previously defined location class. There exist no predefined location classes.</p>"},{"location":"manual/how-the-index-processor-works/#range","title":"range","text":"<p>A range is a pair of location-references. A sequence of location references following one another is transformed into an range if the length of the sequence exceeds a certain user-definable limit. For example, the location references 11, 12, 13 and 14 may be transformed into the range 11--14. See command <code>define-location-class</code> for further details.</p>"},{"location":"manual/how-the-index-processor-works/#cross-reference-group","title":"cross-reference-group","text":"<p>Container for all cross-references of a particular cross-reference-class.</p>"},{"location":"manual/how-the-index-processor-works/#cross-reference-class-cross-reference","title":"cross-reference-class, cross-reference","text":"<p>A cross-reference is an unstructured reference. Cross-reference-classes are used to define different classes of cross references. All elements of a cross reference class appear together in the index. A cross reference consists of a list of strings.</p>"},{"location":"manual/how-the-index-processor-works/#attributes","title":"attributes","text":"<p>Each location reference contains a so-called attribute. Attributes may be used to give a location reference a different meaning that may influence the processing and markup of this reference. Sometimes location references pointing to semantically different locations such as a definition or a usage of a term are tagged differently. They often appear in italics or boldface indicating this difference. An attribute may now be used to express this difference. Since xindy needs to know the possible attributes before the index entries are read in, the command <code>define-attributes</code> must be used to define a set of attributes and how they interact.</p>"},{"location":"manual/invoking-xindy/","title":"Invoking xindy","text":""},{"location":"manual/invoking-xindy/#command-line-options","title":"Command Line Options","text":"<p>The following command line options are accepted:</p> <pre><code>xindy  [-h] [-t] [-v] [-l logfile] [-o outfile]\n       [-L n] [-f filterprog]\n       indexstyle raw-index\n</code></pre> <p>The argument <code>indexstyle</code> names a file, containing the index style description. The argument <code>raw-index</code> names a file, containing the raw index. Both arguments are mandatory.</p> <code>-h</code> Gives a short summary of all command line options. <code>-l</code> Writes helpful information into the specified <code>logfile</code>. For example, the keyword mappings are written into this file, so one can check if the intended mappings were actually performed this way. <code>-o</code> Explicitly defines the name of the <code>output</code> file. If not given, the name of the <code>raw-index</code> is used with its extension changed to <code>`.ind</code>' (or added, if it had no extension at all). <code>-t</code> Enters tracing mode of the symbolic markup tags. The format of the emitted tags can be defined with the command <code>markup-trace</code>. <code>-L</code> Sets the xindy logging-level to n. <code>-f</code> Runs <code>filterprog</code> on <code>raw-index</code> before reading. The program must act as a filter reading from stdin and writing to stdout. The most obvious use of this option in conjunction with TeX is to run <code>-f tex2xindy</code> on the index file prior to reading the entries into xindy. <code>-v</code> Shows the version number of xindy. <p>Errors and warnings are reported to <code>stdout</code> and additionally to the logfile if <code>-l</code> was specified.</p>"},{"location":"manual/invoking-xindy/#search-path","title":"Search Path","text":"<p>The system uses the concept of a search path for finding the index style files and modules. The searchpath can be set with the environment variable <code>XINDY_SEARCHPATH</code> which must contain a list of colon-separated directories. If it ends with a colon, the built-in searchpath is added to the entire searchpath. See the command <code>searchpath</code> for further details.</p>"},{"location":"manual/processing-phases/","title":"Processing Phases","text":""},{"location":"manual/processing-phases/#the-startup-phase","title":"The Startup Phase","text":"<p>After the system is started, xindy reads in the index style that is passed as a command line argument. Each <code>require</code> command is executed and the internal data structures representing the index style are built up. The index style must completely be read in before the raw index can be read.</p>"},{"location":"manual/processing-phases/#the-processing-phase","title":"The Processing Phase","text":"<p>The processing phase starts with reading the complete raw index. The name of the raw index file must be passed via the command line. All index entries are read in and pre-processed. All attributes and cross reference classes are checked if they are already known to the system. All strings representing location references are matched against all known location classes. Appropriate warnings are issued, if errors are encountered.</p> <p>After the raw index has completely been read in, the location references of each index entry are merged, separated and sorted and the building of ranges takes place. This phase is the most complex one and we will describe it in detail.</p> <ol> <li>All location references are separated according to the class they    belong to. These groups are called location class groups. Possible    groups are all defined location and crossref classes. See the    commands <code>define-location-class</code> and <code>define-crossref-class</code> for a    description of how these classes can be defined. The classes are    sorted according to an order defined with    <code>define-location-class-order</code>.</li> <li> <p>The processing of each location class group differs for location     classes and crossref classes:</p> <ul> <li>Cross references are sorted lexicographically based on the   ISO-Latin alphabet.</li> <li> <p>For location references, consider the following list:</p> <p><code>text _13_, _14_, _15_, _18_, **12**, **13**, **14**, **16**, 14, 16</code></p> </li> </ul> <p>Italics use the <code>important</code> attribute, bold values use <code>definition</code>, and unformatted values are <code>default</code>. Assume these attribute groups:</p> <p>```lisp (define-attribute-groups ((\"definition\" \"important\")                           (\"default\")))</p> <p>(merge-to \"definition\" \"default\" :drop) ```</p> <p>Substitution rules turn the list into:</p> <p>13, 14, 15, 18, 12, 16, 14, 16</p> <p>because the attribute groups implicitly define <code>\"definition\"</code>  substituting <code>\"important\"</code>.</p> <p><code>merge-to</code> adds helper references (shown in parentheses) to aid  range building:</p> <p>13, 14, 15, 18, 12, 16, (13), 14, (15), 16, (18)</p> <p>Parents are the original values, while the generated entries are  children used only for range construction.</p> <p>Ranges are then built per attribute. Because <code>:drop</code> is set, the  process starts with the <code>default</code> attribute, producing the range  <code>13--16</code>. The children (13) and (15) were used to form that range,  so parents 13 and 15 are dropped. After unsuccessful attempts  to extend ranges and removing (18), the remaining list is:</p> <p>14, 18, 12, 16, 13--16</p> <p>Attributes are finally ordered and merged lexicographically,  yielding:</p> <p>(12, 14, 16, 18) (13--16)</p> </li> </ol> <p>After all index entries have been processed the letter groups are formed and the index entries and location references are transformed into tree like structures as defined in the index style.</p>"},{"location":"manual/processing-phases/#the-markup-phase","title":"The Markup Phase","text":"<p>After the index has completely been processed, the markup phase traverses the tree-like structure of the index. Each step triggers the appropriate markup events resulting in the emitting of markup tags. This phase can be traced by using the command line option <code>-t</code>.</p>"},{"location":"manual/references/","title":"References","text":"<p>The following books and papers were referenced in this document.</p> <ol> <li>D. E. Knuth, The TeXbook, Addison-Wesley, 1984</li> <li>Leslie Lamport, LaTeX A Document Preparation System, Addison-Wesley, 1986</li> <li>Joachim Schrod, An International Version of MakeIndex, Cahiers GUTenberg, 10, p81-90, 1991</li> <li>Pehong Chen and Michael A. Harrison, Automating Index Preparation, TR-87/347, University of California Berkeley, 1987</li> <li>Roger Kehr, xindy, Ein Flexibles Indexierungssystem, Studienarbeit FB Informatik, TH-Darmstadt, November 1995.</li> <li>Joachim Schrod and Gabor Herr, MakeIndex Version 3.0, Technical University Darmstadt, 1991</li> <li>Roger Kehr, xindy -- A Flexible Indexing System, Proceedings of the EuroTeX'98, St. Malo, France, March 1998</li> </ol>"},{"location":"manual/by-topic/","title":"xindy by Topic","text":"<p>Edition February 1998 (xindy 2.0). A quick, question-driven guide for practitioners who want answers fast.</p>"},{"location":"manual/by-topic/by-topic-references/","title":"References","text":"<p>The following books and papers were referenced in this document:</p> <ol> <li>D. E. Knuth, The TeXbook, Addison-Wesley, 1984</li> <li>Leslie Lamport, LaTeX A Document Preparation System, Addison-Wesley, 1986</li> <li>Joachim Schrod, An International Version of MakeIndex, Cahiers GUTenberg, 10, p81-90, 1991</li> <li>Pehong Chen and Michael A. Harrison, Automating Index Preparation, TR-87/347, University of California Berkeley, 1987</li> <li>Roger Kehr, xindy Ein Flexibles Indexierungssystem, Studienarbeit FB Informatik, TH-Darmstadt, November 1995.</li> <li>Joachim Schrod and Gabor Herr, MakeIndex Version 3.0, Technical University of Darmstadt, 1991</li> <li>Roger Kehr, xindy -- A Flexible Indexing System, Technical Report No. 11/1997, Computer Science Department, Darmstadt University of Technology, 1997. Also accessible from the xindy homepage.</li> <li>Roger Kehr, xindy -- A Flexible Indexing System, Proceedings of the EuroTeX'98, St. Malo, France, March 1998</li> </ol>"},{"location":"manual/by-topic/errors-and-problems/","title":"Errors and Problems","text":""},{"location":"manual/by-topic/errors-and-problems/#the-keyword-mappings-dont-work-as-expected","title":"The keyword mappings don't work as expected!","text":"<p>Sometimes the keyword mappings don't work as expected. Especially in cases with several regular expressions one might get confused about what rule matches exactly when. We have incorporated a detailed logging mechanism that lets one step by step follow the rules that accomplish the keyword mapping.</p> <p>When running xindy you can turn on this feature with the command line option <code>-L`'. This option followed by one of the numbers 1, 2, or 3 turns on the appropriate debugging level. Turning on level 2 or 3 and specifying a log-file with the command line option</code>-l`' a trace of the mappings is recorded in the log-file. A sample output looks like the following:</p> <pre><code>Mappings: (add (merge-rule :eregexp `^\\\\bf{(.*)}' `\\1' :again)).\nMappings: (add (merge-rule :eregexp `^\\\\\"([AEOUaeou])' `\\1')).\n ...\nMappings: (compare `\\\"A\\\"a' :eregexp `^\\\\bf{(.*)}')\nMappings: (compare `\\\"A\\\"a' :eregexp `^\\\\\"([AEOUaeou])') match!\nMappings: (compare `\\\"a' :eregexp `^\\\\bf{(.*)}')\nMappings: (compare `\\\"a' :eregexp `^\\\\\"([AEOUaeou])') match!\nMappings: (merge-mapping `\\\"A\\\"a') -&gt; `Aa'.\n</code></pre> <p>This trace shows that initially two regular expression mappings have been added to the rule set. The second section shows how the keyword <code>\\\"A\\\"a</code> is compared to these rules and substitutions are applied as matches are found. In the last line the result of the keyword mapping is reported.</p>"},{"location":"manual/by-topic/errors-and-problems/#im-totally-confused-by-the-markup-scheme","title":"I'm totally confused by the markup scheme!","text":"<p>A very important feature is the ability to trace all markup tags xindy emits in the markup phase. Simply use the command line switch <code>-t</code> or insert the command</p> <pre><code>(markup-trace :on)\n</code></pre> <p>into the index style. This informs xindy to emit additional pseudo markup that can be used to understand and debug the markup phase. An example output might look like the following:</p> <pre><code>&lt;INDEX:OPEN&gt;\n  &lt;LETTER-GROUP-LIST:OPEN&gt;\n    &lt;LETTER-GROUP:OPEN [\"a\"]&gt;\n      &lt;INDEXENTRY-LIST:OPEN [0]&gt;\n        &lt;INDEXENTRY:OPEN [0]&gt;\n          &lt;KEYWORD-LIST:OPEN [0]&gt;\n            &lt;KEYWORD:OPEN [0]&gt;\n ...\n</code></pre> <p>The symbolic tags directly lead one to the command that is responsible for the definition of that markup tag. For example, the tag <code>LETTER-GROUP-LIST:OPEN</code>  indicates that the command <code>markup-letter-group-list</code>  is responsible for replacing this symbolic tag by a real one. Give it a try if you find yourself confused by your own markup specification.</p>"},{"location":"manual/by-topic/how-to/","title":"How to \u2026","text":""},{"location":"manual/by-topic/how-to/#dont-want-to-write-style-files-how-can-i-proceed","title":"don't want to write style files. How can I proceed?","text":"<p>You can use the wrapper program <code>makeindex4</code>. It tries to do it's very best to make xindy behave as <code>makeindex</code> does. But if you ever need to use some of the features of xindy you should learn how to write an index style. Its easy!</p>"},{"location":"manual/by-topic/how-to/#eventually-i-decided-to-write-my-first-index-style-how-can-i-start","title":"Eventually, I decided to write my first index style. How can I start?","text":"<p>Congratulations! You have made a good decision, indeed.</p> <p>For a first impression, how a style file can be written from scratch reference the tutorial that comes with this distribution. It is written as a guided step-by-step practicing exercise and you can learn the basic concepts quite easily.</p> <p>Afterwards, the best starting point is to make a copy of the template file that contains all the necessary commands that are needed to make a <code>makeindex</code>-like index. You can find it in the subdirectory <code>markup/tex</code> of the module library. Starting from this template you can remove or add commands as necessary.</p> <p>Additionally, consult the library of predefined index style modules that comes with this distribution. Solutions for most of the typical problems can be found there, such as a module for doing case-insensitive sorting rules, or a typical TeX-like markup. Most of the time is is enough to include some of these modules and add a few additional commands.</p> <p>Maybe some of the examples coming with the test-suite are good examples of how unusual index style files can be written.</p> <p>Thus, there are many ways to learn writing an index style file. But it is very easy and after some experience you can process indexes your friends will be jealous of.</p>"},{"location":"manual/by-topic/how-to/#how-do-i-use-makeindex4","title":"How do I use <code>makeindex4</code>?","text":"<p>Process your document as usual. Then run <code>makeindex4</code> on the index file. It produces an index that should equal the one you would get with an ordinary <code>makeindex</code> run. As far as you are satisfied with the default behaviour of <code>makeindex</code>, <code>makeindex4</code> will produce comparable results.</p> <p>Some of the command-line options of <code>makeindex</code> are accepted by <code>makeindex4</code>, others aren't. This may change in future releases, but we recommend using plain xindy after a phase of investigation, since one cannot use all of its features with <code>makeindex4</code>. You will be informed about unsupported command-line arguments when running <code>makeindex4</code>.</p> <p>Python port note: this implementation supports <code>-g/-q/-r/-p/-s</code> and multiple <code>.idx</code> files; <code>.ist</code> files are partially converted and may emit warnings for unsupported keys.</p> <p>If you have written special style files for <code>makeindex</code> they will no longer work with <code>makeindex4</code>. Go ahead and write a new style file for xindy.</p>"},{"location":"manual/by-topic/how-to/#why-a-completely-new-indexing-tool-makeindex-works-fine","title":"Why a completely new indexing tool? <code>makeindex</code> works fine!","text":"<p>With the International MakeIndex project, Joachim Schrod and Gabor Herr [3, 6] have shown that adding extensions to <code>makeindex</code> is a difficult job. Thus we have decided to develop a new indexing tool from scratch. The new tool is based on a new requirements analysis and offers very interesting features for processing very complex indexing schemes. The resulting index model is described in [5, 7, 8].</p>"},{"location":"manual/by-topic/how-to/#im-an-old-makeindex-wizard-what-does-xindy-offer-that-makeindex-doesnt","title":"I'm an old <code>makeindex</code> wizard. What does xindy offer that <code>makeindex</code> doesn't?","text":"<p>Here are the most important differences between xindy and <code>makeindex</code>:</p> <ul> <li> <p>Internationalization. xindy can be configured to process     indexes for many languages with different letter sets and different     sorting rules. For example, many roman languages such as Italian,     French, Portuguese or Spanish contain accentuated letters such as     \u00c0, \u00c1, \u00f1. Other languages from northern Europe     have letters like \u00c4, \u00d8, \u00e6 or \u00df which often     can't be processed by many index processors not talking about sorting     them correctly into an index. The xindy-system can be configured     to process these alphabets by defining sort and     merge-rules that allow expressing of language specific rules.     One example of such a rule would be</p> <p><code>(sort-rule '\u00e4' 'ae')</code></p> <p>defining that a word containing the umlaut-a will be sorted as if it contained the letters <code>ae</code> instead. This is one form of how the umlaut-a is sorted into german indexes. With an appropriate set of rules one can express the complete rules of a specific language.</p> </li> <li> <p>Location classes. <code>makeindex</code> is able to recognize and   process arabic numbers, roman numerals and letter-based alphabets as   specifiers for the indexed location. Simple composite structures of   these are also possible to process. This implicit recognition scheme   has completely been dropped in favour of a well-defined and very   powerful declaration scheme called location-classes. Thus,   xindy initally does not know any location-class by default and   must be instructed to accept certain location-classes. A typical   declaration might look like:</p> <p><code>(define-location-class \"page-numbers\" (\"arabic-numbers\"))</code></p> </li> </ul> <p>This declares that page numbers consist of the enumeration of the arabic numbers. The arabic numbers are referred to as alphabets. Users may use the pre-defined alphabets arabic numbers, roman numerals, etc. or define new alphabets as needed. See the tutorial that comes with this distribution for some examples.</p> <ul> <li>The concept of attributes. With <code>makeindex</code> one can assign a markup to each index entry using the encapsulators (usually following the vertical bar sign in an index entry command). For example in the specification</li> </ul> <p><code>text    \\index{xindy|bold}</code></p> <p>the encapsulator is <code>bold</code> which encapsulates the page-numbers in the markup-phase. An additional TeX-macro must be supplied to assign some markup with the page number. This concept has completely been dropped in xindy in favour of a more powerful scheme called attributes. Attributes can be used to (i) define several grouping and ordering rules with locations and we can define (ii) markup-tags for the document preparation system.</p> <p>The result of this design decision is that the user is required to define the attributes in the style file and not in the document preparation system. The reasons lie in the more powerful markup scheme of xindy which can't be specified in the document processor anymore. In fact, the <code>makeindex</code>-like markup is only a small subset of xindys features.</p> <ul> <li> <p>Cross references. Cross-references were implemented in <code>makeindex</code> with the encapsulation mechanism, which only served for markup purposes. This has been completely separated in xindy. Here we distinguish cleanly between attributes and cross references. This makes it possible to implement checked cross references, i.e. cross-refernces that can be checked if they point to an existing index entry instead of somewhere ``behind-the-moon''.</p> </li> <li> <p>Less command-line options. xindy has dropped the usage of command-line options in favour of a well-defined indexstyle description language. Thus, options that could be activated at the command-line level of <code>makeindex</code> must now be specified in the indexstyle file. This sounds more restrictive than it is, because the indexstyle files can be composed from several modules which makes it possible to write style files in just a few lines of code.</p> </li> <li> <p>Raw index parser. The parser built into <code>makeindex</code> has completely been separated from the core xindy system. xindy understands a well-defined specification language for the raw index that is completely different from <code>makeindex</code>, but in our opinion more maintainable than the <code>makeindex</code> format. This requires a separate filter that transforms arbitrary indexes to the xindy format. An example filter is the program <code>tex2xindy</code> that comes with this distribution.</p> </li> </ul> <p>Summed up, some of the implicit assumptions made by <code>makeindex</code> have been replaced and now burdend to the user. The reason is that many of <code>makeindex</code>'s assumptions were no longer valid in multi-language environments or documents with arbitrary location structures. This also characterizes xindy more as a framework instead of a end-user-tailored product. One should notice that writing an appropriate index style is an essential part of the document preparation process and should be tailored to each document anew.</p>"},{"location":"manual/by-topic/how-to/#what-is-tex2xindy","title":"What is <code>tex2xindy</code>?","text":"<p><code>tex2xindy</code> is a filter that parses <code>`.idx</code>' or similar files and converts the <code>\\indexentry</code>  macros into a form readable by xindy.</p> <p>The parser of <code>makeindex</code> can be configured to recognize different quoting characters, etc. (see the man-page for <code>makeindex</code>, section input style specifiers for further details). We have tried to extract the parser from <code>makeindex</code> but due to several probems we have finally rewritten the parser using <code>lex</code>. Scanners written with <code>lex</code> are usually fixed to a specific character set used in the regular expressions. Our parser, <code>tex2xindy</code> is therefore not configurable. If one uses a different configuration of the <code>makeindex</code> input style specifiers, one can change the source (<code>tex2xindy.l</code>) to generate a completely new parser. From our personal experience we have rarely used more than two different parsers in practice so we have written <code>tex2xindy</code> in a form that is easily maintainable. The input specifiers are stored symbolically in the source. The definiton section looks like this:</p> <pre><code>KEYWORD  \\\\indexentry\nENCAP    \\|\nACTUAL   @\nESCAPE   \\\\\nLEVEL    !\nQUOTE    \\\"\nROPEN    \\(\nRCLOSE   \\)\nARGOPEN  \\{\nARGCLOSE \\}\n</code></pre> <p>These definitions are essentially the input style specifiers as can be found in the man-page of <code>makeindex</code>. Changing this section according to your needs and recompiling <code>tex2xindy</code> should be an easy task. Maybe we will include more pre-defined parsers in future releases if necessary.</p>"},{"location":"manual/by-topic/how-to/#how-to-write-my-first-index-style","title":"How to write my first index style?","text":"<p>Copy the file <code>tex/makeidx.xdy</code> from the library to your local directory. It is documented in in a way that should make it easy to fill in new commands or remove or modify others.</p>"},{"location":"manual/by-topic/how-to/#how-works-makeindex4","title":"How works <code>makeindex4</code>?","text":"<p>This job is now done automatically by <code>makeindex4</code>. It calls <code>tex2xindy</code> to transform the raw-index into the format suitable for xindy. <code>tex2xindy</code> emits some information about the attributes (aka. encapsulators in <code>makeindex</code>) and the usage of cross-references into a file, which has the extension <code>`.sta</code>'. The <code>makeindex4</code> program, written in <code>perl</code>, parses this statistics-file and generates the above presented indexstyle commands for you automatically including the required declaration of all attributes in the whole index and their markup.</p> <p>Another problem is the automatic detection of cross-references. As noted above, <code>makeindex</code> handles cross-references with its encapsulation mechanism, a scheme which has been dropped in xindy and replaced by a more powerful mechanism. To implement a simple plug-in mechanism we have extended the syntax of the <code>tex2xindy</code> filter to identify encapsulators of the form</p> <pre><code>\\indexentry{...|encap{...}}{...}\n</code></pre> <p>as a cross-reference, whereas encapsulators of the form</p> <pre><code>\\indexentry{...|encap}{...}\n</code></pre> <p>are treated as ordinary attributes. This is standard practice defining cross-references in <code>makeindex</code>. Thus, <code>tex2xindy</code> distinguishes these two forms of encapsulators as opposed to <code>makeindex</code> and our plug-in <code>makeindex4</code> generates the appropriate definitions of the cross-reference classes as well.</p>"},{"location":"manual/by-topic/how-to/#how-works-the-actual-key-feature-of-makeindex-with-xindy","title":"How works the actual key feature of <code>makeindex</code> with xindy?","text":"<p>The treatment of the actual key (usually denoted with <code>@</code>, the at-sign) has changed with xindy. Specifying index entries with a specific markup can be done in <code>makeindex</code> with the actual key. The <code>makeindex-3</code> system and xindy offer the merge- and sort-rules to transform a key into different representations, limiting the need to specify an actual key. For example they support a style of writing</p> <pre><code>\\index{\\bf{VIP}}\n</code></pre> <p>which can be transformed with a rule like</p> <pre><code>(merge-rule \"\\bf{\\(.*\\)}\" \"\\1\" :again :bregexp)\n</code></pre> <p>which removes the macro definition for merging and sorting keywords, but keeping the original definition for markup purposes. Therefore we don't need any actual keys for all keywords written in boldface.</p> <p>The <code>makeindex</code> behaviour, that the two keywords</p> <pre><code>\\index{VIP}\n\\index{VIP@\\bf{VIP}}\n</code></pre> <p>are seen as two distinct index entries, can be simulated using the following definition:</p> <pre><code>(merge-rule \"\\bf{\\(.*\\)}\" \"\\1~e\" :again :bregexp)\n</code></pre> <p>This rule tells xindy to remove the boldface macro for merging and sorting purposes but defines the replacement to include the special character <code>~e</code>, which is the last character in the alphabet (ISO-Latin in our case). This makes xindy treat them as different keywords and positions the boldface keyword right behind the one without any markup. Thus we receive the following mapping:</p> <pre><code>Keyword:    Merged and sorted as:   Appears in the index as:\nVIP              VIP                     VIP\n\\bf{VIP}         VIP~e                   \\bf{VIP}\n</code></pre> <p>With this new style of writing keywords and defining their markup, the need to explicitly specifying the print key (aka. actual key) has convinced us to remove the <code>makeindex</code> way of defining keywords.</p>"},{"location":"manual/by-topic/how-to/#i-want-to-process-an-index-for-my-native-language-what-must-i-do","title":"I want to process an index for my native language. What must I do?","text":"<p>What makes <code>makeindex</code> hardly usable in non-English speaking countries is its lack of support of language specific alphabets and sort orderings. For example, many roman languages such as Italian, French, Portuguese or Spanish contain accented letters such as \u00c0, \u00c1, \u00f1. Other languages from northern Europe have letters like \u00c4, \u00d8, \u00e6 or \u00df which often can't even be processed by many index processors let alone sorting them correctly into an index.</p> <p>Two problems must be solved when processing indexes with a new languages:</p> <ol> <li>The sort ordering of the indexed terms must be specified in an appropriate manner. This problem can be solved using the so-called keyword mappings.</li> <li>The letter groups that partition the indexed terms into separate sections must be specified.</li> </ol> <p>The xindy system can be configured to process these alphabets by defining sort and merge rules that allow expressing language specific rules.</p> <p>The keyword mappings are as follows: The merge key is generated from the main key with the so called merge mapping. The merge mapping can be specified with the command <code>merge-rule</code>. The sort key is derived from the merge key using the sort mapping specified with the <code>sort-rule</code> command. The following scheme shows this mapping process:</p> <p></p> <p>The index style commands accomplishing this task are <code>sort-rule</code> and <code>merge-rule</code>. One example of such a rule would be</p> <pre><code>(sort-rule \"\u00e4\" \"ae\")\n</code></pre> <p>defining that a word containing the umlaut-a will be sorted as if it contained the letters <code>ae</code> instead. This is one form of how the umlaut-a (\u00e4) is sorted into german indexes. With an appropriate set of rules on can express the complete rules of a specific language.</p> <p>An example of how an appropriate mapping for some of the Roman languages could look like is:</p> <pre><code>(sort-rule \"\u00e0\" \"a\")\n(sort-rule \"\u00e1\" \"a\")\n(sort-rule \"\u00e3\" \"a\")\n(sort-rule \"\u00e8\" \"e\")\n(sort-rule \"\u00e9\" \"e\")\n(sort-rule \"\u00e7\" \"c\")\n</code></pre> <p>This makes the accented letters be sorted as their unaccented counterparts, yielding the desired sort ordering.</p> <p>Sometimes it is necessary to specify keyword mappings that tell the system to put something behind something else. For instance, we'd like to map the character \u00f6 behind the letter o. No problem if you use the special characters <code>~b</code> and <code>~e</code> which are called the beginning and ending characters. The first letter lexicographically precedes all other letters whereas the latter one comes after all others. Our mapping problem can now be specified as follows.</p> <pre><code>(sort-rule \"\u00f6\" \"o~e\")\n</code></pre> <p>Now the \u00f6 is directly positioned after the o but before p.</p> <p>See the manual for a detailed description of this feature. Also be informed that the keyword mappings can be specified with regular expressions. Rules of the form</p> <pre><code>(merge-rule \"[-$()]\" \"\")\n</code></pre> <p>are possible. This on removes all letters of the defined letter class. Regular expression substitutions are possible as well. Refer to the manual for an exact description.</p>"},{"location":"manual/by-topic/how-to/#in-my-index-the-capitalized-words-appear-after-the-lowercase-words-why","title":"In my index the capitalized words appear after the lowercase words. Why?","text":"<p>The default sort ordering sorts letters according to their ordinal number in the ISO Latin alphabet. As a consequence the lowercase letters appear before the uppercase letters. To sort them case-insensitively use the command</p> <pre><code>(require \"lang/latin/caseisrt.xdy\")\n</code></pre> <p>This module defines the appropriate sort rules for the letters `A-Z' for latin-based alphabets. If your language has more letters simply add the missing ones into your style file. Have a look at the module to see how to the sort rules are defined.</p>"},{"location":"manual/by-topic/how-to/#in-my-index-there-are-no-letter-groups-yet","title":"In my index there are no letter groups, yet!","text":"<p>Letter groups for latin based alphabets can be defined with the command</p> <pre><code>(require \"lang/latin/letgroup.xdy\")\n</code></pre> <p>If your language needs additional letter groups you can insert them into the previously defined letter group with inserting definitions of the following form:</p> <pre><code>(define-letter-group \"ly\" :after \"l\" :before \"m\")\n(define-letter-group \"ny\" :after \"n\" :before \"o\")\n</code></pre> <p>This adds two more letter groups to the latin alphabet. Group ly is inserted between l and m, and ny is inserted between n and o. This is how two additional letters of the Hungarian alphabet can be inserted.</p>"},{"location":"manual/by-topic/how-to/#how-can-i-get-rid-of-any-formatting-information-in-the-keyword","title":"How can I get rid of any formatting information in the keyword?","text":"<p>Assume you have index entries containing arbitrary formatting information. For example you write your index entries in TeX in the following form:</p> <pre><code>\\index{\\bf{In boldface please}}\n</code></pre> <p>To avoid specifying for each index entry the print key separately as can be done with the following command</p> <pre><code>\\index{In boldface please@\\bf{In boldface please}}\n</code></pre> <p>you can instead define a rule doing this task for you:</p> <pre><code>(merge-rule \"\\\\bf *{(.*)}\" \"\\1\" :eregexp :again)\n</code></pre> <p>This extended regular expression matches all strings that are surrounded by this formatting command and in the merge phase the formatting command is simply stripped off. Thus, you don't need to write an explicit print key anymore.</p> <p>If for some reason the same word appears more than once in the index, each time having another markup tag as in the following example</p> <pre><code>index\n{\\tt index}\n</code></pre> <p>you must be warned that a rule like</p> <pre><code>(merge-rule \"{\\\\tt *(.*)}\" \"\\1\" :eregexp :again)\n</code></pre> <p>is probably not correct. In this case the above strings are both mapped into the string <code>index</code> thus joining their location references into one index entry. This happens because the result of the merge mapping is used as the equality citerium which views both keywords as equal. To avoid this you should specify instead</p> <pre><code>(merge-rule \"{\\\\tt *(.*)}\" \"\\1~e\" :eregexp :again)\n</code></pre> <p>With the additional meta character <code>~e</code> the substitution of the second key word is placed after the first one making them different index entries. If the second keyword should appear first, use <code>~b</code> instead.</p>"},{"location":"manual/by-topic/how-to/#in-my-index-the-word-foo-appears-before-bar-what-must-i-do","title":"In my index the word -foo appears before bar. What must I do?","text":"<p>Especially for hierarchical indexes sometimes the result is not as expected due to special characters appearing in the keyword. In the following example the word <code>card' should appear before</code>-eyed' since the hyphen should not count as an ordinary character by means of sorting.</p> <pre><code>  green\n     -eyed  12\n     card   15\n</code></pre> <p>This is especially problematic if the list of words on the second level is very long. To make the hyphen be simply ignored during the sorting process you should specify the following command in the index style:</p> <pre><code>  (sort-rule \"-\" \"\")\n</code></pre> <p>This makes <code>-eyed' be sorted as</code>eyed' thus making it appear after `card' as desired.</p>"},{"location":"manual/by-topic/how-to/#i-want-to-use-letter-ordering-instead-of-word-ordering-in-my-index","title":"I want to use letter ordering instead of word ordering in my index.","text":"<p>According to the Chicago Manual of Style there exist two different schemes of sorting word lists. In word ordering a blank precedes any letter in the alphabet, whereas in letter ordering it does not count at all. The following example borrowed from the <code>makeindex</code> man-page illustrates the difference:</p> <pre><code> Word Order:         Letter Order:\n  sea lion            seal\n  seal                sea lion\n</code></pre> <p>By default, xindy uses word ordering. To use letter ordering include the appropriate module with the following command:</p> <pre><code>(require \"ord/letorder.xdy\")\n</code></pre> <p>It actually defines the following command:</p> <pre><code>(sort-rule \" \" \"\")\n</code></pre> <p>This simply removes all blanks from the keyword resulting in the desired behaviour.</p>"},{"location":"manual/by-topic/how-to/#my-document-does-not-have-page-numbers-but-a-different-scheme-what-must-i-do","title":"My document does not have page numbers, but a different scheme. What must I do?","text":"<p>The ability to deal with user-definable location structures is one of the most important new features of xindy. Many documents have a document structure that is not based on page numbers. Typical examples are manuals or appendices that come with a chapter/page-per-chapter numbering scheme, URLs, Bible verses, etc. One can even imagine the Greek alphabet as possibly appearing in a location reference. In our analysis we have found many interesting examples of location references that made us to develop the concept of location classes.</p> <p>A location class is defined by a sequence of alphabets. An alphabet can be the set of arabic numbers (0, 1, 2, ...) or the roman numerals (i, ii, iii, ...). These are built-in alphabets in xindy. Addtionally, one can define more alphabets in the index style with a command like</p> <pre><code>  (define-alphabet \"weekdays\"\n         (\"mon\" \"tue\" \"wed\" \"thu\" \"fri\" \"sat\" \"sun\"))\n</code></pre> <p>Based on alphabets one can now compose a location class as follows:</p> <pre><code>  (define-location-class \"weekday-hours\"\n         (\"weekday\" :sep \":\" \"arabic-numbers\"))\n</code></pre> <p>This class description indicates that all location refernces matching this template are viewed as correct instances of this class. Here <code>:sep</code> makes the dot serving as a separation string separation the alphabets from each other. Example instances of this class are:</p> <pre><code>mon:23, thu:45, sun:17\n</code></pre> <p>For more detailed information consult the description of the command <code>define-location-class</code> in the reference manual.</p>"},{"location":"manual/by-topic/how-to/#i-dont-want-to-have-ranges-in-my-index-what-can-i-do","title":"I don't want to have ranges in my index. What can I do?","text":"<p>By default, xindy joins three successive location references into a range. Ranges are used as an abbrevation for a long sequence of location references. For exmaple the sequence</p> <pre><code>12, 13, 14, 15, 16\n</code></pre> <p>would be shorter represented as</p> <pre><code>12-16\n</code></pre> <p>If you don't want to have ranges, simply define your location class in the form</p> <pre><code>  (define-location-class ... :min-range-length none)\n</code></pre> <p>The argument <code>:min-range-length none</code> avoids forming of ranges. Arbitrary numbers instead of <code>none</code> define the minimum length of a sequence of location references that are needed to form a range. xindys default value is 2.</p>"},{"location":"manual/by-topic/how-to/#i-want-to-markup-ranges-of-different-length-differently-how-do-i-accomplish-this","title":"I want to markup ranges of different length differently. How do I accomplish this?","text":"<p>A common way of tagging ranges is as follows: a range of length 1 is printed with the starting page number and the suffix <code>f.', those of length 2 with suffix</code>ff.', and all others in the form `X--Y'.</p> <p>Assume we want to do this for the location class pagenums we can specify the markup as follows:</p> <pre><code>(markup-range :class \"pagenums\" :close \"f.\"  :length 1 :ignore-end)\n(markup-range :class \"pagenums\" :close \"ff.\" :length 2 :ignore-end)\n(markup-range :class \"pagenums\" :sep \"--\")\n</code></pre> <p>The first command indicates that a range (X,Y) of length 1 should be printed in the form Xf., a range of length 2 as Xff. and all others in the form X--Y. The switch <code>:ignore-end</code> causes the end of range location reference Y to be suppressed in the resulting output.</p>"},{"location":"manual/by-topic/how-to/#i-need-to-suppress-some-of-the-markup-tags-how-can-i-do-this","title":"I need to suppress some of the markup tags. How can I do this?","text":"<p>Sometimes it is necessary to hide some of the parts of the index. If you have a text formatter that allows comments or macros that possibly expand to nothing, just define appropriate markup that makes things invisible to the formatter. For example, with TeX you can define a macro like this</p> <pre><code>\\def\\ignore#1{}\n</code></pre> <p>If you additionally define markup like this</p> <pre><code>(markup-index :open \"\\ignore{\" :close \"}\")\n</code></pre> <p>you can throw away the complete index if you like, which would be a real pity!</p>"},{"location":"manual/by-topic/how-to/#whats-it-all-about-those-cross-references","title":"Whats it all about those cross references?","text":"<p>Cross references are references pointing to an item in the index itself. Typical examples are:</p> <pre><code>foo-bar *see* baz\n</code></pre> <p>With <code>makeindex</code> cross references could be specified with the encapsulation mechanism. This has completely been removed in xindy and we have made cross references real first-class objects.</p> <p>In xindy one can declare different cross reference classes, whose purpose is (a) to make all instances of a certain class appear next to each other, and (b) to specify appropriate markup with them.</p> <p><code>tex2xindy</code> recognises all index entries of the form</p> <pre><code>\\index{...|\\macro{where}}\n</code></pre> <p>as cross references. Here <code>macro</code> stands for an arbitrary macro name and <code>where</code> is interpreted as the target keyword of the cross references.</p> <p>If you want to use these cross references with xindy; add the following line to your style file.</p> <pre><code>  (define-crossref-class \"macro\")\n</code></pre> <p>Additionally, you can assign specific markup to cross references using the <code>markup-crossref</code>-commands.</p>"},{"location":"manual/by-topic/practical-tips/","title":"Practical Tips","text":""},{"location":"manual/by-topic/practical-tips/#what-latex-package-should-i-use-in-conjunction-with-xindy","title":"What LaTeX-package should I use in conjunction with xindy?","text":"<p>We strongly recommend using the LaTeX2e-package <code>index</code> written by David M. Jones, which is available at CTAN. It supports multiple indexes as well as several shortcuts to easily index terms in a document. Multiple indexes support the generation of several indexes for one document. For instance, one can make an author or command index in addition to a global index.</p> <p>Another option is to use the <code>xindy.sty</code> from Andreas Schlechte that comes with the xindy distribution. Take a look at the <code>contrib</code> directory that should contain a version.</p>"},{"location":"manual/by-topic/practical-tips/#what-editor-should-i-use-when-writing-xindy-style-files","title":"What editor should I use when writing xindy style files?","text":"<p>Use <code>Emacs</code> or <code>XEmacs</code>. Turn on the Lisp-mode with</p> <pre><code>M-x lisp-mode\n</code></pre> <p>and you can properly indent commands using <code>M-q</code>. To enter this mode automatically add the following lines to the end of the style file:</p> <pre><code>^L\n;; Local Variables:\n;; mode: lisp\n;; End:\n</code></pre> <p>The <code>^L</code> (Control-L) can be entered with <code>C-q C-l</code>.</p>"},{"location":"manual/by-topic/practical-tips/#have-written-a-module-for-processing-language-foolandic-what-must-i-do","title":"have written a module for processing language foolandic. What must I do?","text":"<p>Great! Send it to us! It will become a part of the system in the next release.</p>"},{"location":"manual/manpages/makeindex4/","title":"makeindex4 (manpage)","text":"<p>Edition February 1997 \u2014 wrapper around xindy.</p>"},{"location":"manual/manpages/makeindex4/#synopsis","title":"Synopsis","text":"<pre><code>makeindex4 [options]...\n</code></pre>"},{"location":"manual/manpages/makeindex4/#description","title":"Description","text":"<p><code>makeindex4</code> is a wrapper that uses <code>xindy</code> as a replacement for <code>makeindex</code>. It aims for compatibility with <code>makeindex</code> options and warns about unsupported ones. Requires <code>tex2xindy</code> and <code>xindy</code>.</p>"},{"location":"manual/manpages/makeindex4/#python-port-notes","title":"Python port notes","text":"<p>The Python port implements common <code>makeindex</code> flags plus additional compatibility:</p> <ul> <li>Supports <code>-c/-l/-o/-t</code> and <code>-g/-q/-r/-p/-s</code>, as well as multiple <code>.idx</code> inputs.</li> <li><code>-s</code> accepts <code>.xdy</code> or a subset of <code>.ist</code> keys (unsupported keys emit warnings).</li> <li><code>-i</code> reads from stdin (output defaults to stdout if <code>-o</code> is omitted).</li> <li><code>-p any|odd|even</code> uses the corresponding <code>.log</code> file to infer the starting page.</li> </ul>"},{"location":"manual/manpages/makeindex4/#see-also","title":"See also","text":"<p><code>xindy(1L)</code>, <code>makeindex(1L)</code>, <code>tex2xindy(1L)</code></p>"},{"location":"manual/manpages/tex2xindy/","title":"tex2xindy (manpage)","text":"<p>Edition January 1997 \u2014 frontend filter for xindy.</p>"},{"location":"manual/manpages/tex2xindy/#synopsis","title":"Synopsis","text":"<pre><code>tex2xindy [file]\n</code></pre>"},{"location":"manual/manpages/tex2xindy/#description","title":"Description","text":"<p><code>tex2xindy</code> reads from stdin a file in the <code>makeindex</code> input format (<code>.idx</code>) and converts it to the format used by <code>xindy</code>. If <code>file</code> is specified, statistics are written for consumption by <code>makeindex4(1L)</code>.</p>"},{"location":"manual/manpages/tex2xindy/#see-also","title":"See also","text":"<p><code>xindy(1L)</code>, <code>makeindex(1L)</code>, <code>makeindex4(1L)</code></p>"},{"location":"manual/manpages/xindy/","title":"xindy (manpage)","text":"<p>Edition February 1997 \u2014 a flexible indexing system.</p>"},{"location":"manual/manpages/xindy/#synopsis","title":"Synopsis","text":"<pre><code>xindy [-t] [-l logfile] [-o outfile] [-f filterprog] [-L n] [-v]\n  indexstyle rawindex\n</code></pre>"},{"location":"manual/manpages/xindy/#description","title":"Description","text":"<p><code>xindy</code> is a general-purpose index processor driven by an index style and a raw index file.</p>"},{"location":"manual/manpages/xindy/#options","title":"Options","text":"<ul> <li><code>-o outfile</code> \u2014 write the tagged index to <code>outfile</code> (default: <code>rawindex</code> with <code>.ind</code>).</li> <li><code>-l logfile</code> \u2014 write logging information to <code>logfile</code>.</li> <li><code>-f filterprog</code> \u2014 run <code>filterprog</code> on the raw index before reading (stdin \u2192 stdout).</li> <li><code>-L n</code> \u2014 set logging level to 1, 2, or 3.</li> <li><code>-t</code> \u2014 activate <code>markup-trace</code>, emitting symbolic markup tags.</li> <li><code>-v</code> \u2014 display the version number.</li> <li><code>-help</code> \u2014 show a summary of command-line options.</li> </ul>"},{"location":"manual/manpages/xindy/#see-also","title":"See also","text":"<p><code>tex2xindy(1L)</code>, <code>makeindex(1L)</code>, <code>makeindex4(1L)</code></p> <p>For format details of <code>indexstyle</code> and <code>rawindex</code>, see the main manual.</p>"},{"location":"tutorial/","title":"xindy Tutorial","text":"<p>A step-by-step walkthrough of the historical xindy tutorial (Edition March 1997, v1.1). It incrementally builds a complete index style and shows the expected outputs using the sample data in <code>docs/tutorial/</code>.</p>"},{"location":"tutorial/about-xindy/","title":"About xindy","text":"<p>xindy means flexible indexing system. It can generate book-like indexes for many document preparation systems (TeX/LaTeX, the Nroff family, SGML/HTML, etc.). It is configurable and not tied to a single workflow.</p> <p>Authors often need an index but find the built-in tools insufficient, so they use dedicated index processors. xindy offers several features that make it a strong choice:</p> <ul> <li> <p>Internationality: configurable sort/merge rules for many alphabets. Example rule:</p> <p><code>text (sort-rule \"\u00e4\" \"ae\")</code></p> </li> <li> <p>User-definable location types: compose new location classes from     arabic numbers, roman numerals, letters, and separators (e.g. appendix     pages like <code>A-7</code>, or complex structures such as <code>Psalm 46:1-8</code>).</p> </li> <li> <p>Highly configurable markup: environment-based markup system for   TeX/LaTeX, SGML/HTML, GNU Info, RTF, Nroff, and more.</p> </li> </ul>"},{"location":"tutorial/advanced-features/","title":"Advanced Features","text":"<p>In the following sections you'll learn more about the features of xindy. We'll show you how you can define your own location classes, specify the letter groups in more detail and bring you close to more specfic markup features. After reading this chapter you should be able to master about 95% of the commonly used indexes.</p>"},{"location":"tutorial/advanced-features/#location-classes","title":"Location Classes","text":"<p>We continue using a more complex index. Copy the current style to a new file (now <code>style2.xdy</code>) and run xindy on the raw index <code>ex2.raw</code> by typing:</p> <pre><code>$ cp style1.xdy style2.xdy\n$ xindy -l ex2.xlg style2.xdy ex2.raw\n</code></pre> <p>You should see some error messages indicating that something is unknown to xindy. What has happend? The messages should be similar to the following snapshot:</p> <pre><code> ...\nWARNING:\nlocation-reference \"B-5\" did not match any location-class! (ignored)\nWARNING:\nlocation-reference \"C-8\" did not match any location-class! (ignored)\nWARNING:\nlocation-reference \"iv\" did not match any location-class! (ignored)\nWARNING:\nlocation-reference \"ii\" did not match any location-class! (ignored)\n ...\n</code></pre> <p>The index contains new, and therefore unknown, location classes. The first one has an appendix-like style, whereas the second one seems to be lowercase roman numerals. xindy reported, that it doesn't know these locations and therefore knows nothing about their internal structure. We make them known to the system by adding the following commands to the style file.</p> <pre><code>(define-location-class \"roman-pages\" (\"roman-numerals-lowercase\"))\n(define-location-class \"appendices\" (\"ALPHA\" :sep \"-\" \"arabic-numbers\"))\n(define-location-class-order (\"roman-pages\" \"appendices\"))\n</code></pre> <p>The first command tells xindy that there exist some page numbers that are written with roman lowercase letters. The second one defines the structure of the appendix locations. They consist of three elements, a capital letter, a separator---which is a hyphen in our case---and finally an arabic number. To be able to correctly distinguish separator strings from the names of the known basetypes, the argument <code>:sep</code> indicates, that the following is a separator. The last command simply says that the locations which are roman numerals shall appear before the appendix locations. So far we know three different basetypes. The built-in basetypes of xindy are:</p> <ul> <li><code>arabic-numbers</code>: all non-negative numbers beginning with zero (0,   1, 2, ...).</li> <li><code>roman-numerals-uppercase</code>, <code>roman-numerals-lowercase</code>: roman   numerals I, II, III, (IIII/IV), V, ... (old and new systems), with   uppercase and lowercase variants.</li> <li><code>ALPHA</code>, <code>alpha</code>: US-ASCII alphabet letters (uppercase and lowercase).</li> <li><code>digits</code>: the digits 0\u20139 in order.</li> </ul> <p><code>Fine,', you'll say,</code>but what if my basetypes are completely different?' You're right! But xindy offers you to define your own alphabets. For example, you can define a new alphabet by writing</p> <pre><code>(define-alphabet \"my-personal-alphabet\" (\"Hi\" \"ho\" \"here\" \"I\" \"go\"))\n</code></pre> <p>This is a valid alphabet that consists of 5 letters. You can now define a location class</p> <pre><code>(define-location-class \"my-personal-class\"\n    (\"my-personal-alphabet\" :sep \"-\" \"arabic-numbers\"))\n</code></pre> <p>to match all of the following locations: Hi-12, ho-2, here-709, I-9, go-42. xindy will recognize them and be able to sort them according to your specification which says that Hi comes before all others and here is exactly at the third position. So they will be sorted lexicographically, layer by layer, until it can decide which one is before or after the other. We have prepared a concrete example. Do you remember the example we gave when we spoke about indexing bible verses? This exactly matches the situation of such a self-defined alphabet which could look like the following definitions:</p> <pre><code>(define-alphabet \"bible-chapters\"\n    (\"Genesis\" \"Exodus\" \"Leviticus\" \"Numbers\" \"Deuteronomy\"\n     ... ))\n(define-location-class \"bible-verses\"\n    (\"bible-chapters\" :sep \" \" \"arabic-numbers\" :sep \",\" \"arabic-numbers\"))\n</code></pre> <p>This description would match locations like Genesis 1,3, Exodus 7,8, etc.</p> <p>Now run LaTeX on <code>ex2.tex</code> and view the results. It looks a little bit strange since xindy has automatically built ranges of successive locations. The first locations of the index entry roman actually denote the range ii until iv. Ranges consist of location references. To typeset them correctly you can specify</p> <pre><code>(markup-range :sep \"--\")\n</code></pre> <p>This indicates that location reference forming a range shall be separated by a hyphen. Running xindy and LaTeX again gives a better idea of how it should look like. Here is a part of the generated output.</p> <pre><code>  ...\n\\item appendices\\quad{}A-1, A-7, A-11, B-3--B-5, C-1, C-8, C-12,\n         C-13, C-22, D-2, D-3, D-5, D-10\n  ...\n</code></pre>"},{"location":"tutorial/advanced-features/#hierarchical-location-classes","title":"Hierarchical Location Classes","text":"<p>Somehow a lot of space is wasted when looking at the first index entry. Modify the definition of the location class for appendices as follows and add the other commands as well:</p> <pre><code>(define-location-class \"appendices\"\n                       (\"ALPHA\" :sep \"-\" \"arabic-numbers\")\n                       :hierdepth 2)\n(markup-locref-list            :sep \"; \" :depth 0 :class \"appendices\")\n(markup-locref-list :open \"~~\" :sep \", \" :depth 1 :class \"appendices\")\n</code></pre> <p>Note: Since the tilde character serves as our quoting character it must be quoted itself in the above example. Run xindy and view the output stored in <code>ex2.ind</code>. The output looks similar to the following:</p> <pre><code> ...\n\\item appendices\\quad{}A~1, 7, 11; B~3--5; C~1, 8, 12, 13, 22;\n         D~2, 3, 5, 10\n ...\n</code></pre> <p>You can see that the location references of this class have been transformed into a hierarchical structure caused by the <code>:hierdepth</code> argument. Additionally we have specified markup for the layers of this class separately for the depths 0 and 1. The locations at depth 0 are separated by a <code>;' whereas the ones at depth 1 are separated by a</code>,'.</p> <p>Maybe you get an impression why we named xindy a flexible system.</p>"},{"location":"tutorial/advanced-features/#more-about-letter-groups","title":"More about Letter Groups","text":"<p>More problems arise when using languages with different letter schemes. Hungarian is an example. In Hungarian indexes the words beginning with the letters Cs, Ly, Ny and more are printed in a separate block. The words beginning with Ly, for example, appear behind the words beginning with an L. xindy allows to define this kind of letter groups as well. Add the following lines to the style file.</p> <pre><code>(define-letter-group \"ly\" :after \"l\" :before \"m\")\n(define-letter-group \"ny\" :after \"n\" :before \"o\")\n\n(markup-letter-group :open-head \"~n {\\bf \" :close-head \"}\"\n                     :capitalize)\n</code></pre> <p>The result looks like the following:</p> <pre><code>...\n{\\bf Ly}\n\\item lyuk\\quad{}1\n\\item lyukas\\quad{}2\n\n\\indexspace\n\n{\\bf M}\n\\item maga\\quad{}1\n\\item magyar\\quad{}2\n\n\\indexspace\n\n{\\bf N}\n\\item nagy\\quad{}1\n\\item nagyon\\quad{}9\n\\item n\u00e8gy\\quad{}4\n\n\\indexspace\n\n{\\bf Ny}\n\\item nyelv\\quad{}1\n\\item nyolc\\quad{}8\n ...\n</code></pre> <p>The result describes what the purpose of the above commands is. It becomes prettier from step to step, doesn't it?</p> <p>You have now learned most of the features of xindy. Go playing around a little bit. For a detailed description of all commands and all their arguments and switches you should reference the manual that comes with this distribution.</p>"},{"location":"tutorial/basic-introduction/","title":"A Basic Introduction","text":"<p>This section incrementally introduces the most important aspects of the system. After reading this chapter you should be able to specify about 80% of the commonly used indexes. The examples are demonstrated with a TeX markup so one can easily typeset the results xindy produces. You need LaTeX2e and the ISO-Latin enhancements that come with the <code>inputenc</code> package to run the following examples. Also the xindy system must already be installed.</p>"},{"location":"tutorial/basic-introduction/#running-xindy","title":"Running xindy","text":"<p>Create a new directory somewhere and copy some files from the distribution directory <code>Doc/tutorial/</code> by typing</p> <pre><code>$ mkdir tutorial\n$ cd tutorial\n$ cp &lt;distrib-dir&gt;/Doc/tutorial/*.raw .\n$ cp &lt;distrib-dir&gt;/Doc/tutorial/*.tex .\n</code></pre> <p>with <code>distrib-dir</code> replaced by the actual location. Now create a file <code>style1.xdy</code> with the following content:</p> <pre><code>;; This is a first example using `xindy'.\n\n(define-location-class \"page-numbers\" (\"arabic-numbers\"))\n(define-attributes ((\"definition\" \"usage\")))\n\n</code></pre> <p>Now run xindy by typing (the switch <code>`-l</code>' is the lowercase letter `L')</p> <pre><code>$ xindy -l ex1.xlg style1.xdy ex1.raw\n</code></pre> <p>You should see something like</p> <pre><code>This is `xindy' version 1.1 January 1997 (some-arch).\n\nOpening logfile \"ex1.xlg\" (done)\nReading indexstyle...\nLoading module \"style1.xdy\"...\nFinished loading module \"style1.xdy\".\nFinished reading indexstyle.\nFinalizing indexstyle... (done)\n\nReading raw-index \"ex1.raw\"...\nFinished reading raw-index.\n\nProcessing index... [10%] [20%] [30%] [40%] [50%] [60%] [70%] [80%] [90%] [100%]\nFinished processing index.\n\nWriting markup... [10%] [20%] [30%] [40%] [50%] [60%] [70%] [80%] [90%] [100%]\nMarkup written into file \"ex1.ind\".\n\n</code></pre> <p>xindy has now successfully compiled the index <code>ex1.raw</code> using your index style <code>style1.xdy</code>. The result is now stored in file <code>ex1.ind</code>. You can view this file but currently it only contains an unreadable mix of data.</p> <p>But now let's come back to our index style. The syntax of the command is in a Lisp-like form with lots of braces, looking a little bit weird, but you'll soon get used to it. What is the meaning of the two commands we specified? The first command informed xindy that we like to process page numbers. We do this by defining a new location class named <code>page-numbers</code>. The page numbers consist of <code>arabic-numbers</code> as we might expect but this is not necessarily true---imagine your page numbers consisted of roman numerals instead. When reading the raw index contained in file <code>ex1.raw</code> xindy checks all locations if they match all known location classes. Since in our example the only known location class is the class of page numbers which are written using arabic digits, all locations will be checked if they are correct page numbers.</p> <p>The second command tells xindy that we use two types of attributes for location references. Most often the locations in an index denote different meanings. For example, in mathematical texts one will distinguish the definition of a mathematical term from its usage. Sometimes these are typeset using different font shapes such as italic or font series such as boldface. Each location has an associated attribute which, if it is unspecified, defaults to the attribute <code>default</code>. With this command you have made these attributes known to the system, which makes it possible to assign different markup to these attributes later on.</p>"},{"location":"tutorial/basic-introduction/#adding-some-markup","title":"Adding some Markup","text":"<p>Until now you haven't seen something exciting, so its time to specify some markup. Add the following lines to our index style:</p> <pre><code>(markup-index :open  \"~n\\begin{theindex}~n\"\n              :close \"~n\\end{theindex}~n\"\n              :tree)\n\n(markup-locref :class \"page-numbers\" :attr \"definition\"\n               :open  \"{\\bf \" :close \"}\")\n\n(markup-locclass-list :open \"\\quad{}\")\n(markup-locref-list :sep \", \")\n\n</code></pre> <p>Now run xindy again and afterwards LaTeX:</p> <pre><code>$ xindy -l ex1.xlg style1.xdy ex1.raw\n$ latex ex1.tex\n</code></pre> <p>You can view <code>ex1.dvi</code> with your prefered viewer (maybe <code>xdvi</code> or something else) to get a first impression of your results. Maybe your are not satisfied (for sure you aren't), because it still looks very confusing. What did the above rules tell xindy? When you view the file <code>ex1.ind</code> which is the result xindy generates, you'll recognize some of the markup tags you specified. The following is an excerpt of this file:</p> <pre><code>\\begin{theindex}\n  academia\\quad{}{\\bf 1}acafetado\\quad{}{\\bf 2}acalmar\\quad{}{\\bf 4}\n  a\u00e7afr\u00e3o\\quad{}{\\bf 3}indexflat\\quad{}1hierarchical\\quad{}2\n  veryhierarchical\\quad{}3impressive\\quad{}4saber\\quad{}{\\bf 7}\n  sabor\\quad{}{\\bf 8}sab\u00e3o\\quad{}{\\bf 6}s\u00e1bado\\quad{}{\\bf 5}\n\\end{theindex}\n</code></pre> <p>First of all you'll see that the file starts with the string <code>\\begin{theindex}</code>  and ends with <code>\\end{theindex}</code> . Additionally some locations are correctly enclosed into a TeX macro that typesets them in shape boldface, whereas others aren't. The boldface ones are all those locations from the raw index that have the attribute <code>definition</code>.</p> <p>The <code>:open</code> and <code>:close</code> keyword arguments each take a string as argument. The first one is written to the file when opening an enviroment, whereas the latter one closes an environment. What we have specified is the markup for the whole index (which is actually printed only once) and the markup for all locations of class <code>page-numbers</code> which own the attribute <code>definition</code>. Here we have cleanly separated the structured markup from the visual one, allowing an easy redefinition if we decide, for example, to markup the <code>definition</code>-locations in italics instead of boldface.</p> <p>Some words on keyword arguments and switches. Keyword arguments such as <code>:open</code> or <code>:close</code> always take exactly one argument which must be positioned right after the keyword separated by a whitespace (a blank or a tab-stop). Switches don't take any arguments. For example, <code>:tree</code> in the command <code>markup-index</code> is a switch and thus it does not take an argument. We will use this terminology throughout the rest of this document.</p> <p>The third command caused xindy to insert a horizontal space between the keyword and the locations (the TeX command <code>\\quad{}</code>  simply inserts a specific horizontal space). The last command caused xindy to separate all location references from each other with a comma followed by a blank, independently of any location class.</p> <p>As you already may have observed, the tilde sign <code>~</code> serves as a quoting character.</p> <p>We continue specifying markup to get a printable result by adding more markup:</p> <pre><code>(markup-indexentry :open \"~n  \\item \"           :depth 0)\n(markup-indexentry :open \"~n    \\subitem \"      :depth 1)\n(markup-indexentry :open \"~n      \\subsubitem \" :depth 2)\n</code></pre> <p>This assigns different markup for the different hierarchy layers of the indexentries. Our index is hierarchically organized. It contains items which themselves contain more sub-items which also might contain sub-sub-items. Each layer is started by a different markup which is correctly assigned with the <code>:depth</code> keyword argument. The layers are numbered by their depth starting from zero.</p> <p>Now run xindy and TeX again and enjoy your first index. It's easy, isn't it! The output <code>ex1.ind</code> looks like the following:</p> <pre><code>\\begin{theindex}\n\n  \\item academia\\quad{}{\\bf 1}\n  \\item acafetado\\quad{}{\\bf 2}\n  \\item acalmar\\quad{}{\\bf 4}\n  \\item a\u00e7afr\u00e3o\\quad{}{\\bf 3}\n  \\item index\n    \\subitem flat\\quad{}1\n    \\subitem hierarchical\\quad{}2\n    \\subitem very\n      \\subsubitem hierarchical\\quad{}3\n      \\subsubitem impressive\\quad{}4\n  \\item saber\\quad{}{\\bf 7}\n  \\item sabor\\quad{}{\\bf 8}\n  \\item sab\u00e3o\\quad{}{\\bf 6}\n  \\item s\u00e1bado\\quad{}{\\bf 5}\n\n\\end{theindex}\n</code></pre> <p>Hmm, as you might have seen there are several problems that need further investigation. The index contains some Portuguese words that are printed correctly but should appear at other positions inside the index. For instance, the word s\u00e1bado should appear before the word saber since \u00e1 must be sorted as if it were simply an a. The reason why these words are not sorted correctly is simple---the accentuated letters have codes beyond position 128 in the ISO-Latin alphabet. Sorting based on these codes yields this incorrect order.</p> <p>What to do? We can define for each of the words containing these special characters an explicit print key. The print key describes the printed representation of the keyword whereas the key or main key is used for sorting and merging. A very tedious task which is not a very clever solution since in a non-english language many many words contain these special cases. We follow the way xindy offers: keyword-mappings.</p>"},{"location":"tutorial/basic-introduction/#keyword-mappings","title":"Keyword Mappings","text":"<p>What are keyword mappings for? A good question. I'll try to give some answers.</p> <ul> <li>Merging of differently written words. Some text formatting systems allow different writings for the same word. For example, TeX can be used with ISO-Latin characters as well as with its own character sequences. If a document is composed from smaller ones possibly written by different authors using different forms of writing the index entries, the same terms may happen to be written differently and consequently we need a mechanism to identify them as equal.</li> <li>Specifying the sort order. As outlined in the previous section it is really difficult and error-prone to specify the sort key for each keyword explicitly. Sometimes the sort order is even different for the type of the document, as it happens in German, where two different types of sortings exist, one for everyday indexes and one for dictionaries. The sort order actually defines the position of arbitrary language-specific letters inside of an index.</li> </ul> <p>A detailed elaboration of these ideas can be found in the paper An International Version of MakeIndex by Joachim Schrod [3]. It describes the ideas that led to modifications on one of the ancestors of the xindy system: <code>makeindex</code> [4].</p> <p>The keyword mappings are as follows. The merge key is generated from the main key with the so called merge mapping. The merge mapping can be specified with the command <code>merge-rule</code>. The sort key is derived from the merge key using the sort mapping specified with the <code>sort-rule</code> command. The following scheme shows this mapping process:</p> <p></p> <p>We will use this command now to define a suitable sort mapping that fits our needs:</p> <pre><code>(sort-rule \"\u00e0\" \"a\")\n(sort-rule \"\u00e1\" \"a\")\n(sort-rule \"\u00e3\" \"a\")\n(sort-rule \"\u00e8\" \"e\")\n(sort-rule \"\u00e9\" \"e\")\n(sort-rule \"\u00e7\" \"c\")\n</code></pre> <p>These rules define mappings from a keyword to a normalized version. In the logfile <code>ex1.xlg</code> these transformations are logged so that one can see how these mappings are performed. In this example we do not need any <code>merge-rule</code> but we will see applications in further examples.</p> <p>Running xindy and TeXing the result now places the indexentries at the right positions.</p> <p>The result is now quite satisfying if the index entries weren't clumped together that much. We usually want the different index entries beginning with the same letter be optically separated from the ofhers. This improves readability and there must be a way to accomplish this---the letter groups.</p>"},{"location":"tutorial/basic-introduction/#letter-groups","title":"Letter Groups","text":"<p>To group indexentries we must define what indexentries form a group. The clustering is done by matching the keywords' prefixes (taken from the sort key) with a user-defined table of prefixes and define appropriate markup that separates the groups from each other. Here it goes.</p> <pre><code>(define-letter-groups\n  (\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\"\n   \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"))\n\n(markup-letter-group-list :sep \"~n\\indexspace\")\n</code></pre> <p>This defines the given list of letter groups. When forming the letter groups, each letter group is checked if it matches a prefix of the indexentries' sort key. The longest match assigns the index entry to this letter group. If no match was possible the index entry is put into group <code>default</code>.</p> <p>The result now looks much better than before. You have now learned the basic features that you need to specify everyday indexes. In the next chapter we'll continue to make you an expert in indexing.</p>"},{"location":"tutorial/tutorial-references/","title":"References","text":"<p>The following books and papers were referenced in this document.</p> <ul> <li>D. E. Knuth, The TeXbook, Addison-Wesley, 1984</li> <li>Leslie Lamport, LaTeX A Document Preparation System, Addison-Wesley, 1986</li> <li>Joachim Schrod, An International Version of MakeIndex, Cahiers GUTenberg, 10, p81-90, 1991</li> <li>Pehong Chen and Michael A. Harrison, Automating Index Preparation, TR-87/347, University of California Berkeley, 1987</li> <li>Roger Kehr, xindy, Ein Flexibles Indexierungssystem, Studienarbeit FB Informatik, TH-Darmstadt, November 1995.</li> </ul>"}]}